var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Course Content 1. Introduction What is SQL? Types of Databases (Relational vs Non-Relational) SQL vs NoSQL SQL Standards (ANSI SQL, T-SQL, PL/SQL, MySQL SQL, PostgreSQL SQL) 2. SQL Basics Database, Schema, Table Data Types (Numeric, String, Date/Time, Boolean, JSON, XML) CREATE, DROP, ALTER INSERT, UPDATE, DELETE SELECT Statement WHERE Clause ORDER BY LIMIT / TOP / FETCH 3. Filtering \u0026 Operators Comparison Operators Logical Operators (AND, OR, NOT) BETWEEN, IN, LIKE IS NULL / IS NOT NULL Pattern Matching (Wildcards, Regex) 4. Functions String Functions (CONCAT, SUBSTRING, TRIM, UPPER, LOWER, LENGTH) Numeric Functions (ROUND, CEIL, FLOOR, ABS, MOD) Date/Time Functions (NOW, DATEADD, DATEDIFF, FORMAT) Conversion Functions (CAST, CONVERT) Aggregate Functions (COUNT, SUM, AVG, MIN, MAX) 5. Joins INNER JOIN LEFT JOIN RIGHT JOIN FULL OUTER JOIN CROSS JOIN SELF JOIN USING vs ON 6. Subqueries \u0026 Nested Queries Scalar Subqueries Table Subqueries Correlated Subqueries EXISTS / NOT EXISTS IN / ANY / ALL 7. Set Operations UNION vs UNION ALL INTERSECT EXCEPT / MINUS 8. Grouping \u0026 Aggregation GROUP BY HAVING GROUPING SETS ROLLUP CUBE 9. Constraints \u0026 Keys Primary Key Foreign Key Unique Key Check Constraint Default Constraint Not Null 10. Indexing \u0026 Performance Clustered vs Non-Clustered Index Composite Index Covering Index Index Maintenance Query Execution Plans SQL Performance Tuning 11. Transactions BEGIN, COMMIT, ROLLBACK Savepoints ACID Properties Isolation Levels (Read Uncommitted, Read Committed, Repeatable Read, Serializable, Snapshot) Deadlocks \u0026 Locking 12. Views \u0026 Materialized Views Creating Views Updatable Views Indexed Views Materialized Views Refresh Strategies 13. Stored Procedures \u0026 Functions User-Defined Functions (Scalar, Table-Valued) Stored Procedures Parameters (IN, OUT, INOUT) Error Handling in Procedures Recursive Procedures Dynamic SQL 14. Triggers AFTER Trigger INSTEAD OF Trigger Row-level vs Statement-level Triggers Use Cases 15. Advanced SQL Window Functions (ROW_NUMBER, RANK, DENSE_RANK, NTILE) LAG \u0026 LEAD FIRST_VALUE \u0026 LAST_VALUE Common Table Expressions (CTEs) Recursive CTEs Pivoting and Unpivoting JSON \u0026 XML in SQL Hierarchical Queries Full-Text Search 16. Security Users \u0026 Roles GRANT, REVOKE, DENY Row-Level Security Column-Level Security Data Masking Encryption at Rest \u0026 In-Transit 17. Advanced Database Concepts Normalization \u0026 Denormalization Star \u0026 Snowflake Schema Partitioning (Horizontal, Vertical) Sharding Federation Replication High Availability \u0026 Failover 18. SQL with Big Data SQL on Hadoop / Hive Spark SQL SQL in Cloud Platforms (AWS Athena, BigQuery, Azure Synapse) 19. SQL in Practice Data Warehousing with SQL ETL using SQL Reporting Queries Performance Benchmarking Debugging Complex Queries 20. Capstone Project Design \u0026 Implement Normalized Database Build ETL Pipeline using SQL Create Analytical Queries \u0026 Reports Optimize Large-Scale SQL Workloads",
    "description": "Course Content 1. Introduction What is SQL? Types of Databases (Relational vs Non-Relational) SQL vs NoSQL SQL Standards (ANSI SQL, T-SQL, PL/SQL, MySQL SQL, PostgreSQL SQL) 2. SQL Basics Database, Schema, Table Data Types (Numeric, String, Date/Time, Boolean, JSON, XML) CREATE, DROP, ALTER INSERT, UPDATE, DELETE SELECT Statement WHERE Clause ORDER BY LIMIT / TOP / FETCH 3. Filtering \u0026 Operators Comparison Operators Logical Operators (AND, OR, NOT) BETWEEN, IN, LIKE IS NULL / IS NOT NULL Pattern Matching (Wildcards, Regex) 4. Functions String Functions (CONCAT, SUBSTRING, TRIM, UPPER, LOWER, LENGTH) Numeric Functions (ROUND, CEIL, FLOOR, ABS, MOD) Date/Time Functions (NOW, DATEADD, DATEDIFF, FORMAT) Conversion Functions (CAST, CONVERT) Aggregate Functions (COUNT, SUM, AVG, MIN, MAX) 5. Joins INNER JOIN LEFT JOIN RIGHT JOIN FULL OUTER JOIN CROSS JOIN SELF JOIN USING vs ON 6. Subqueries \u0026 Nested Queries Scalar Subqueries Table Subqueries Correlated Subqueries EXISTS / NOT EXISTS IN / ANY / ALL 7. Set Operations UNION vs UNION ALL INTERSECT EXCEPT / MINUS 8. Grouping \u0026 Aggregation GROUP BY HAVING GROUPING SETS ROLLUP CUBE 9. Constraints \u0026 Keys Primary Key Foreign Key Unique Key Check Constraint Default Constraint Not Null 10. Indexing \u0026 Performance Clustered vs Non-Clustered Index Composite Index Covering Index Index Maintenance Query Execution Plans SQL Performance Tuning 11. Transactions BEGIN, COMMIT, ROLLBACK Savepoints ACID Properties Isolation Levels (Read Uncommitted, Read Committed, Repeatable Read, Serializable, Snapshot) Deadlocks \u0026 Locking 12. Views \u0026 Materialized Views Creating Views Updatable Views Indexed Views Materialized Views Refresh Strategies 13. Stored Procedures \u0026 Functions User-Defined Functions (Scalar, Table-Valued) Stored Procedures Parameters (IN, OUT, INOUT) Error Handling in Procedures Recursive Procedures Dynamic SQL 14. Triggers AFTER Trigger INSTEAD OF Trigger Row-level vs Statement-level Triggers Use Cases 15. Advanced SQL Window Functions (ROW_NUMBER, RANK, DENSE_RANK, NTILE) LAG \u0026 LEAD FIRST_VALUE \u0026 LAST_VALUE Common Table Expressions (CTEs) Recursive CTEs Pivoting and Unpivoting JSON \u0026 XML in SQL Hierarchical Queries Full-Text Search 16. Security Users \u0026 Roles GRANT, REVOKE, DENY Row-Level Security Column-Level Security Data Masking Encryption at Rest \u0026 In-Transit 17. Advanced Database Concepts Normalization \u0026 Denormalization Star \u0026 Snowflake Schema Partitioning (Horizontal, Vertical) Sharding Federation Replication High Availability \u0026 Failover 18. SQL with Big Data SQL on Hadoop / Hive Spark SQL SQL in Cloud Platforms (AWS Athena, BigQuery, Azure Synapse) 19. SQL in Practice Data Warehousing with SQL ETL using SQL Reporting Queries Performance Benchmarking Debugging Complex Queries 20. Capstone Project Design \u0026 Implement Normalized Database Build ETL Pipeline using SQL Create Analytical Queries \u0026 Reports Optimize Large-Scale SQL Workloads",
    "tags": [],
    "title": "SQL",
    "uri": "/sql/"
  },
  {
    "breadcrumb": "",
    "content": "1. Introduction Overview of Azure Data Factory Data Integration in Cloud ADF Architecture ADF Components (Pipelines, Activities, Datasets, Linked Services, Triggers) ADF vs SSIS vs Synapse Pipelines 2. ADF Basics Creating an ADF Instance ADF Studio Overview Linked Services Datasets Pipelines Activities Triggers (Schedule, Tumbling Window, Event-based, Manual) 3. Data Movement Copy Activity Integration Runtime (IR) Types Azure IR Self-hosted IR Azure-SSIS IR Data Movement Performance Parallelism \u0026 Batch Copy 4. Data Transformation Mapping Data Flows Wrangling Data Flows Data Flow Debugging Joins, Aggregations, Filters, Derived Columns Surrogate Keys \u0026 Window Functions Data Flow Performance Tuning 5. Orchestration Control Activities (Execute Pipeline, ForEach, If Condition, Until, Switch, Wait) Parameterization Variables in Pipelines Expressions \u0026 Functions Dynamic Content Error Handling \u0026 Retry Policies 6. Data Sources \u0026 Destinations Azure Blob Storage Azure Data Lake Storage (ADLS) Azure SQL Database Azure Synapse Analytics On-Premises SQL Server Cosmos DB REST API SAP, Oracle, Teradata, Snowflake Amazon S3 Google Cloud Storage 7. Integration with Other Azure Services Azure Key Vault Integration Azure Monitor \u0026 Log Analytics Power BI Integration Event Grid \u0026 Event Hub Logic Apps \u0026 Functions Azure Machine Learning 8. CI/CD \u0026 DevOps with ADF Source Control with Git (GitHub, Azure Repos) Branching \u0026 Collaboration Publishing \u0026 ARM Templates Continuous Integration \u0026 Deployment Automated Testing Environment Promotion (Dev → Test → Prod) 9. Security Managed Identity in ADF Service Principals Access Control (RBAC) Data Encryption Network Security (VNET Integration, Private Endpoints) Credential Management with Key Vault 10. Monitoring \u0026 Troubleshooting Pipeline Monitoring Activity Run Details Debugging Failures Alerts \u0026 Notifications Logging with Log Analytics Performance Optimization 11. Advanced Features Incremental Data Loading (Watermarking, Change Data Capture) Slowly Changing Dimensions (SCD) Implementation Parameterized Pipelines \u0026 Templates Global Parameters Data Lineage \u0026 Impact Analysis ADF REST API Managed VNET Data Integration 12. Best Practices Designing Efficient Pipelines Naming Conventions Error Handling Framework Cost Optimization in ADF Scalability \u0026 Performance Tuning Version Control Strategies 13. Real-World Use Cases Building an ETL Pipeline with ADF Data Lake to Synapse ETL Real-Time Event Processing Hybrid Data Integration (On-Prem + Cloud) Machine Learning Model Deployment Orchestration 14. Capstone Project End-to-End Data Warehouse Load using ADF Incremental Data Pipeline with Delta Processing Enterprise Data Integration with ADF and Synapse",
    "description": "1. Introduction Overview of Azure Data Factory Data Integration in Cloud ADF Architecture ADF Components (Pipelines, Activities, Datasets, Linked Services, Triggers) ADF vs SSIS vs Synapse Pipelines 2. ADF Basics Creating an ADF Instance ADF Studio Overview Linked Services Datasets Pipelines Activities Triggers (Schedule, Tumbling Window, Event-based, Manual) 3. Data Movement Copy Activity Integration Runtime (IR) Types Azure IR Self-hosted IR Azure-SSIS IR Data Movement Performance Parallelism \u0026 Batch Copy 4. Data Transformation Mapping Data Flows Wrangling Data Flows Data Flow Debugging Joins, Aggregations, Filters, Derived Columns Surrogate Keys \u0026 Window Functions Data Flow Performance Tuning 5. Orchestration Control Activities (Execute Pipeline, ForEach, If Condition, Until, Switch, Wait) Parameterization Variables in Pipelines Expressions \u0026 Functions Dynamic Content Error Handling \u0026 Retry Policies 6. Data Sources \u0026 Destinations Azure Blob Storage Azure Data Lake Storage (ADLS) Azure SQL Database Azure Synapse Analytics On-Premises SQL Server Cosmos DB REST API SAP, Oracle, Teradata, Snowflake Amazon S3 Google Cloud Storage 7. Integration with Other Azure Services Azure Key Vault Integration Azure Monitor \u0026 Log Analytics Power BI Integration Event Grid \u0026 Event Hub Logic Apps \u0026 Functions Azure Machine Learning 8. CI/CD \u0026 DevOps with ADF Source Control with Git (GitHub, Azure Repos) Branching \u0026 Collaboration Publishing \u0026 ARM Templates Continuous Integration \u0026 Deployment Automated Testing Environment Promotion (Dev → Test → Prod) 9. Security Managed Identity in ADF Service Principals Access Control (RBAC) Data Encryption Network Security (VNET Integration, Private Endpoints) Credential Management with Key Vault 10. Monitoring \u0026 Troubleshooting Pipeline Monitoring Activity Run Details Debugging Failures Alerts \u0026 Notifications Logging with Log Analytics Performance Optimization 11. Advanced Features Incremental Data Loading (Watermarking, Change Data Capture) Slowly Changing Dimensions (SCD) Implementation Parameterized Pipelines \u0026 Templates Global Parameters Data Lineage \u0026 Impact Analysis ADF REST API Managed VNET Data Integration 12. Best Practices Designing Efficient Pipelines Naming Conventions Error Handling Framework Cost Optimization in ADF Scalability \u0026 Performance Tuning Version Control Strategies 13. Real-World Use Cases Building an ETL Pipeline with ADF Data Lake to Synapse ETL Real-Time Event Processing Hybrid Data Integration (On-Prem + Cloud) Machine Learning Model Deployment Orchestration 14. Capstone Project End-to-End Data Warehouse Load using ADF Incremental Data Pipeline with Delta Processing Enterprise Data Integration with ADF and Synapse",
    "tags": [],
    "title": "Azure Data Factory",
    "uri": "/azure_data_factory/"
  },
  {
    "breadcrumb": "",
    "content": "1. Introduction Big Data Overview Introduction to Apache Spark Introduction to Azure Databricks Databricks Architecture Databricks Workspace Overview 2. Spark Core Concepts RDDs (Resilient Distributed Datasets) Transformations and Actions Lazy Evaluation Spark Execution Model Caching and Persistence Partitioning 3. Spark SQL DataFrames and Datasets Spark SQL Engine Schema Inference Catalog and Metadata Temporary and Global Views SQL Queries in Spark Performance Optimization (Catalyst Optimizer, Tungsten) 4. Spark Data Sources Reading/Writing CSV, JSON, Parquet, ORC Working with Delta Lake JDBC Data Sources Streaming Data Sources Handling Nested Data (Struct, Array, Map) 5. Delta Lake Introduction to Delta Lake ACID Transactions Schema Enforcement \u0026 Evolution Time Travel Upserts \u0026 Deletes (MERGE) Delta Lake Optimization (Z-order, Optimize, Vacuum) 6. Spark Streaming \u0026 Structured Streaming Introduction to Streaming DStreams vs Structured Streaming Streaming Sources (Kafka, Event Hubs, Socket) Watermarking \u0026 Late Data State Management Streaming Sinks (Delta, Console, Kafka, Event Hubs) 7. Spark MLlib (Machine Learning) MLlib Basics Feature Engineering Pipelines \u0026 Transformers Classification Regression Clustering Model Persistence 8. Spark GraphX Introduction to GraphX Graph Processing Basics Graph Algorithms Use Cases 9. Performance Tuning Spark Configurations \u0026 Parameters Memory Management Shuffle Optimizations Caching Strategies Adaptive Query Execution (AQE) Skew Handling 10. Azure Databricks Essentials Databricks Clusters (Types, Autoscaling, Pools) Databricks Notebooks Databricks Repos \u0026 Git Integration Databricks Jobs \u0026 Scheduling Databricks Secrets Databricks Utilities (DBUtils) Workspace Security \u0026 Permissions 11. Integration with Azure Services Azure Data Lake Storage (ADLS) Integration Azure Blob Storage Integration Azure Synapse Analytics Azure Event Hubs Azure Data Factory (ADF) with Databricks Power BI with Databricks 12. Advanced Databricks Unity Catalog Databricks SQL Delta Live Tables (DLT) Databricks REST API Databricks CLI Monitoring \u0026 Logging Cost Optimization in Databricks 13. Real-World Use Cases ETL Pipeline with Databricks Streaming Data Pipeline Batch Data Processing Machine Learning Pipeline End-to-End Data Lakehouse Implementation 14. Best Practices Cluster Sizing \u0026 Configuration Code Versioning \u0026 Collaboration Data Governance Security \u0026 Compliance CI/CD with Databricks Productionizing Workloads 15. Capstone Project Build a Scalable Data Lakehouse with Databricks Real-Time Streaming Data Pipeline ML Model Training and Deployment",
    "description": "1. Introduction Big Data Overview Introduction to Apache Spark Introduction to Azure Databricks Databricks Architecture Databricks Workspace Overview 2. Spark Core Concepts RDDs (Resilient Distributed Datasets) Transformations and Actions Lazy Evaluation Spark Execution Model Caching and Persistence Partitioning 3. Spark SQL DataFrames and Datasets Spark SQL Engine Schema Inference Catalog and Metadata Temporary and Global Views SQL Queries in Spark Performance Optimization (Catalyst Optimizer, Tungsten) 4. Spark Data Sources Reading/Writing CSV, JSON, Parquet, ORC Working with Delta Lake JDBC Data Sources Streaming Data Sources Handling Nested Data (Struct, Array, Map) 5. Delta Lake Introduction to Delta Lake ACID Transactions Schema Enforcement \u0026 Evolution Time Travel Upserts \u0026 Deletes (MERGE) Delta Lake Optimization (Z-order, Optimize, Vacuum) 6. Spark Streaming \u0026 Structured Streaming Introduction to Streaming DStreams vs Structured Streaming Streaming Sources (Kafka, Event Hubs, Socket) Watermarking \u0026 Late Data State Management Streaming Sinks (Delta, Console, Kafka, Event Hubs) 7. Spark MLlib (Machine Learning) MLlib Basics Feature Engineering Pipelines \u0026 Transformers Classification Regression Clustering Model Persistence 8. Spark GraphX Introduction to GraphX Graph Processing Basics Graph Algorithms Use Cases 9. Performance Tuning Spark Configurations \u0026 Parameters Memory Management Shuffle Optimizations Caching Strategies Adaptive Query Execution (AQE) Skew Handling 10. Azure Databricks Essentials Databricks Clusters (Types, Autoscaling, Pools) Databricks Notebooks Databricks Repos \u0026 Git Integration Databricks Jobs \u0026 Scheduling Databricks Secrets Databricks Utilities (DBUtils) Workspace Security \u0026 Permissions 11. Integration with Azure Services Azure Data Lake Storage (ADLS) Integration Azure Blob Storage Integration Azure Synapse Analytics Azure Event Hubs Azure Data Factory (ADF) with Databricks Power BI with Databricks 12. Advanced Databricks Unity Catalog Databricks SQL Delta Live Tables (DLT) Databricks REST API Databricks CLI Monitoring \u0026 Logging Cost Optimization in Databricks 13. Real-World Use Cases ETL Pipeline with Databricks Streaming Data Pipeline Batch Data Processing Machine Learning Pipeline End-to-End Data Lakehouse Implementation 14. Best Practices Cluster Sizing \u0026 Configuration Code Versioning \u0026 Collaboration Data Governance Security \u0026 Compliance CI/CD with Databricks Productionizing Workloads 15. Capstone Project Build a Scalable Data Lakehouse with Databricks Real-Time Streaming Data Pipeline ML Model Training and Deployment",
    "tags": [],
    "title": "Azure Data Bricks",
    "uri": "/azure_data_bricks/"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "breadcrumb": "",
    "content": "Contents Azure DataBricks SQL Azure Data Factory aksjdf lksajflkasjd fl;ajsd fl;ajs dfl;kajsd fs;kjlsjflkalfja sdlf aldj;sdljkafdadfjasdlsdjfljsfadlkfsd fas;d jf;laks df;jd;las;ljaldsl;afl aslf;sdf ;ldkslksla fls dflsdf;la;sjdf ;ldskjsdj;asdk ;sd;lsjf;js flajsfl;asdf;jas;fadsf;lsjf;sd jf;lsf;lasjf; asdkf a;sdkf ;aldsj f;alsdjk f;ldsk;ljfl;akslkj flasdfl; adl;",
    "description": "Contents Azure DataBricks SQL Azure Data Factory aksjdf lksajflkasjd fl;ajsd fl;ajs dfl;kajsd fs;kjlsjflkalfja sdlf aldj;sdljkafdadfjasdlsdjfljsfadlkfsd fas;d jf;laks df;jd;las;ljaldsl;afl aslf;sdf ;ldkslksla fls dflsdf;la;sjdf ;ldskjsdj;asdk ;sd;lsjf;js flajsfl;asdf;jas;fadsf;lsjf;sd jf;lsf;lasjf; asdkf a;sdkf ;aldsj f;alsdjk f;ldsk;ljfl;akslkj flasdfl; adl;",
    "tags": [],
    "title": "Data Engineering Notes",
    "uri": "/"
  },
  {
    "breadcrumb": "ADB",
    "content": "Joins in PySpark In PySpark Joins are used to combine two DataFrames based on a common column or condition.\nTypes of Joins in PySpark Inner Join: Matches rows from both DataFrames. df1.join(df2, df1.common_column == df2.common_column, \"inner\") Left/Right Join: Keeps all rows from the left or right DataFrame and matches where possible. df1.join(df2, df1.common_column == df2.common_column, \"left\") df1.join(df2, df1.common_column == df2.common_column, \"right\") Full Join: Keeps all rows from both DataFrames. df1.join(df2, df1.common_column == df2.common_column, \"outer\") Left Semi: Filters df1 to rows that match df2 without including columns from df2. df1.join(df2, df1.common_column == df2.common_column, \"left_semi\") Left Anti: Filters df1 to rows that do not match df2. df1.join(df2, df1.common_column == df2.common_column, \"left_anti\") Cross Join: Returns the Cartesian product, combining all rows of both DataFrames. df1.crossJoin(df2) Explicit Condition Join: Allows complex join conditions, including columns with different names. df1.join(df2, df1.columnA == df2.columnB, \"inner\") df1.join(df2, df1.common_column == df2.common_column, \"inner\") df1.join(df2, df1.common_column == df2.common_column, \"left\") df1.join(df2, df1.common_column == df2.common_column, \"right\") df1.join(df2, df1.common_column == df2.common_column, \"outer\") df1.join(df2, df1.common_column == df2.common_column, \"left_semi\") df1.join(df2, df1.common_column == df2.common_column, \"left_anti\") df1.crossJoin(df2) df1.join(df2, df1.columnA == df2.columnB, \"inner\") Practice-1 from pyspark.sql import SparkSession from pyspark.sql import Row from pyspark.sql.functions import broadcast # Initialize Spark session spark = SparkSession.builder.appName(\"JoinsExample\").getOrCreate() # Sample DataFrames data1 = [Row(id=0), Row(id=1), Row(id=1), Row(id=None), Row(id=None)] data2 = [Row(id=1), Row(id=0), Row(id=None)] df1 = spark.createDataFrame(data1) df2 = spark.createDataFrame(data2) # Inner Join inner_join = df1.join(df2, on=\"id\", how=\"inner\") print(\"Inner Join:\") inner_join.show() # Right Join right_join = df1.join(df2, on=\"id\", how=\"right\") print(\"Right Join:\") right_join.show() # Full (Outer) Join full_join = df1.join(df2, on=\"id\", how=\"outer\") print(\"Full (Outer) Join:\") full_join.show() # Left Anti Join left_anti_join = df1.join(df2, on=\"id\", how=\"left_anti\") print(\"Left Anti Join:\") left_anti_join.show() # Right Anti Join (Equivalent to swapping DataFrames and performing Left Anti Join) right_anti_join = df2.join(df1, on=\"id\", how=\"left_anti\") print(\"Right Anti Join:\") right_anti_join.show() # Broadcast Join (Optimizing a join with a smaller DataFrame) broadcast_join = df1.join(broadcast(df2), on=\"id\", how=\"inner\") print(\"Broadcast Join:\") broadcast_join.show() Practice 2 PySpark Coding Questions Find employees whose location matches the location of their department\nDisplay: emp_id, emp_name, emp_location, dept_name, dept_location. Find departments that have no employees assigned to them\nDisplay: dept_id, dept_name, dept_head. Get the average salary of employees in each department\nDisplay: dept_name, average_salary. List the employees who earn more than the average salary of their department\nDisplay: emp_id, emp_name, emp_salary, dept_name, dept_location. # Sample DataFrames emp_data = [ Row(emp_id=1, emp_name=\"Alice\", emp_salary=50000, emp_dept_id=101, emp_location=\"New York\"), Row(emp_id=2, emp_name=\"Bob\", emp_salary=60000, emp_dept_id=102, emp_location=\"Los Angeles\"), Row(emp_id=3, emp_name=\"Charlie\", emp_salary=55000, emp_dept_id=101, emp_location=\"Chicago\"), Row(emp_id=4, emp_name=\"David\", emp_salary=70000, emp_dept_id=103, emp_location=\"San Francisco\"), Row(emp_id=5, emp_name=\"Eve\", emp_salary=48000, emp_dept_id=102, emp_location=\"Houston\") ] dept_data = [ Row(dept_id=101, dept_name=\"Engineering\", dept_head=\"John\", dept_location=\"New York\"), Row(dept_id=102, dept_name=\"Marketing\", dept_head=\"Mary\", dept_location=\"Los Angeles\"), Row(dept_id=103, dept_name=\"Finance\", dept_head=\"Frank\", dept_location=\"Chicago\") ] emp_columns = [\"emp_id\", \"emp_name\", \"emp_salary\", \"emp_dept_id\", \"emp_location\"] dept_columns = [\"dept_id\", \"dept_name\", \"dept_head\", \"dept_location\"] emp_df = spark.createDataFrame(emp_data, emp_columns) dept_df = spark.createDataFrame(dept_data, dept_columns) # Display emp data print(\"emp_data:\") emp_df.show() # Display dept data print(\"dept_data:\") dept_df.show() # Inner Join on emp_dept_id and dept_id inner_join = emp_df.join(dept_df, emp_df[\"emp_dept_id\"] == dept_df[\"dept_id\"], \"inner\") # Display the result print(\"Inner Join Result:\") inner_join.show() # Inner Join with Filtering Columns and WHERE Condition inner_join = emp_df.join(dept_df, emp_df[\"emp_dept_id\"] == dept_df[\"dept_id\"], \"inner\") \\ .select(\"emp_id\", \"emp_name\", \"emp_salary\", \"dept_name\", \"dept_location\") \\ .filter(\"emp_salary \u003e 55000\") # Add a WHERE condition # Display the result print(\"Inner Join with Filter and WHERE Condition:\") inner_join.show() # Left Join with Filtering Columns and WHERE Condition left_join_filtered = emp_df.join(dept_df, emp_df[\"emp_dept_id\"] == dept_df[\"dept_id\"], \"left\") \\ .select(\"emp_id\", \"emp_name\", \"dept_name\", \"dept_location\") \\ .filter(\"emp_salary \u003e 55000\") # Add a WHERE condition # Display the result print(\"Left Join with Filter and WHERE Condition:\") left_join_filtered.show() # Left Anti Join left_anti_join = emp_df.join( dept_df, emp_df[\"emp_dept_id\"] == dept_df[\"dept_id\"], \"left_anti\" ) # Display the result print(\"Left Anti Join Result:\") left_anti_join.show() Practice 3 PySpark Coding Questions List each employee along with their manager’s name\nDisplay: employee, manager. Find employees who do not have a manager (CEO-level employees)\nDisplay: employee, manager. Find all employees who directly report to “Manager A”\nDisplay: empid, ename, mrgid. Determine the hierarchy level of each employee\nCEO → Level 1, direct reports to CEO → Level 2, and so on. Display: empid, ename, mrgid, level. from pyspark.sql import SparkSession from pyspark.sql.functions import col, expr # Create a Spark session spark = SparkSession.builder.appName(\"EmployeeHierarchy\").getOrCreate() # Sample data data = [ (1, None, \"CEO\"), (2, 1, \"Manager A\"), (3, 1, \"Manager B\"), (4, 2, \"Employee X\"), (5, 3, \"Employee Y\"), ] columns = [\"empid\", \"mrgid\", \"ename\"] employee_df = spark.createDataFrame(data, columns) # Display the result print(\"emp_data:\") employee_df.show() # Self-join to find the manager and CEO manager_df = employee_df.alias(\"e\") \\ .join(employee_df.alias(\"m\"), col(\"e.mrgid\") == col(\"m.empid\"), \"left\") \\ .select( col(\"e.ename\").alias(\"employee\"), col(\"m.ename\").alias(\"manager\") ) # Display the result print(\"mgr:\") manager_df.show() # Filter for employees without a manager (CEO) manager_df2 = employee_df.alias(\"e1\") \\ .join(employee_df.alias(\"m1\"), col(\"e1.mrgid\") == col(\"m1.empid\"), \"left\") \\ .select( col(\"e1.ename\").alias(\"employee\"), col(\"m1.ename\").alias(\"manager\") ) \\ .filter(col(\"manager\").isNull()) # Display the result manager_df2.show()",
    "description": "Joins in PySpark In PySpark Joins are used to combine two DataFrames based on a common column or condition.\nTypes of Joins in PySpark Inner Join: Matches rows from both DataFrames. df1.join(df2, df1.common_column == df2.common_column, \"inner\") Left/Right Join: Keeps all rows from the left or right DataFrame and matches where possible. df1.join(df2, df1.common_column == df2.common_column, \"left\") df1.join(df2, df1.common_column == df2.common_column, \"right\") Full Join: Keeps all rows from both DataFrames. df1.join(df2, df1.common_column == df2.common_column, \"outer\") Left Semi: Filters df1 to rows that match df2 without including columns from df2. df1.join(df2, df1.common_column == df2.common_column, \"left_semi\") Left Anti: Filters df1 to rows that do not match df2. df1.join(df2, df1.common_column == df2.common_column, \"left_anti\") Cross Join: Returns the Cartesian product, combining all rows of both DataFrames. df1.crossJoin(df2) Explicit Condition Join: Allows complex join conditions, including columns with different names. df1.join(df2, df1.columnA == df2.columnB, \"inner\") df1.join(df2, df1.common_column == df2.common_column, \"inner\") df1.join(df2, df1.common_column == df2.common_column, \"left\") df1.join(df2, df1.common_column == df2.common_column, \"right\") df1.join(df2, df1.common_column == df2.common_column, \"outer\") df1.join(df2, df1.common_column == df2.common_column, \"left_semi\") df1.join(df2, df1.common_column == df2.common_column, \"left_anti\") df1.crossJoin(df2) df1.join(df2, df1.columnA == df2.columnB, \"inner\") Practice-1 from pyspark.sql import SparkSession from pyspark.sql import Row from pyspark.sql.functions import broadcast # Initialize Spark session spark = SparkSession.builder.appName(\"JoinsExample\").getOrCreate() # Sample DataFrames data1 = [Row(id=0), Row(id=1), Row(id=1), Row(id=None), Row(id=None)] data2 = [Row(id=1), Row(id=0), Row(id=None)] df1 = spark.createDataFrame(data1) df2 = spark.createDataFrame(data2) # Inner Join inner_join = df1.join(df2, on=\"id\", how=\"inner\") print(\"Inner Join:\") inner_join.show() # Right Join right_join = df1.join(df2, on=\"id\", how=\"right\") print(\"Right Join:\") right_join.show() # Full (Outer) Join full_join = df1.join(df2, on=\"id\", how=\"outer\") print(\"Full (Outer) Join:\") full_join.show() # Left Anti Join left_anti_join = df1.join(df2, on=\"id\", how=\"left_anti\") print(\"Left Anti Join:\") left_anti_join.show() # Right Anti Join (Equivalent to swapping DataFrames and performing Left Anti Join) right_anti_join = df2.join(df1, on=\"id\", how=\"left_anti\") print(\"Right Anti Join:\") right_anti_join.show() # Broadcast Join (Optimizing a join with a smaller DataFrame) broadcast_join = df1.join(broadcast(df2), on=\"id\", how=\"inner\") print(\"Broadcast Join:\") broadcast_join.show() Practice 2 PySpark Coding Questions Find employees whose location matches the location of their department",
    "tags": [],
    "title": "Joins",
    "uri": "/azure_data_bricks/joins/"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/"
  },
  {
    "breadcrumb": "ADB",
    "content": "when and otherwise The when and otherwise functions in PySpark provide a way to create conditional expressions within a DataFrame, allowing you to specify different values for new or existing columns based on specific conditions.\nwhen:\nThe when function in PySpark is used to define a condition.\nIf the condition is met, it returns the specified value.\nYou can chain multiple when conditions to handle various cases.\notherwise:\nThe otherwise function specifies a default value to return if none of the conditions in the when statements are met.\nfrom pyspark.sql import SparkSession from pyspark.sql.functions import when from pyspark.sql.types import StructType, StructField, IntegerType, StringType # Initialize Spark session spark = SparkSession.builder.appName(\"WhenOtherwiseExample\").getOrCreate() # Define the schema for the dataset schema = StructType([ StructField(\"name\", StringType(), True), StructField(\"age\", IntegerType(), True), StructField(\"salary\", IntegerType(), True) ]) # Create a sample dataset data = [ (\"Alice\", 25, 3000), (\"Bob\", 35, 4000), (\"Charlie\", 40, 5000), (\"David\", 28, 4500), (\"Eve\", 32, 3500) ] # Create DataFrame df = spark.createDataFrame(data, schema) df.show() # Apply 'when' and 'otherwise' to add new columns based on conditions df = ( df.withColumn(\"status\", when(df.age \u003c 30, \"Young\").otherwise(\"Adult\")) .withColumn(\"income_bracket\", when(df.salary \u003c 4000, \"Low\") .when((df.salary \u003e= 4000) \u0026 (df.salary \u003c= 4500), \"Medium\") .otherwise(\"High\")) ) # Show the result df.show() Explanation status column\nAssigns \"Young\" if age \u003c 30. Otherwise assigns \"Adult\". income_bracket column\nAssigns \"Low\" if salary \u003c 4000. Assigns \"Medium\" if 4000 \u003c= salary \u003c= 4500. Assigns \"High\" for any other salary values. This approach allows for flexible handling of multiple conditions in PySpark DataFrames using when and otherwise.\ncast() and printSchema() In PySpark, the cast() function is used to change the data type of a column within a DataFrame.\nThis is helpful when you need to standardize column data types for data processing, schema consistency, or compatibility with other operations.\nPurpose:\nThe cast() function allows you to change the data type of a column, useful in situations like standardizing formats (e.g., converting strings to dates or integers).\nSyntax:\nThe cast() function is applied on individual columns and requires specifying the target data type in quotes.\nMultiple Columns:\nYou can cast multiple columns at once by using a list of cast expressions and passing them to select().\nSupported Data Types:\nPySpark supports various data types for casting, including:\nStringType IntegerType (or \"int\") DoubleType (or \"double\") DateType TimestampType BooleanType Others, based on the data types available in PySpark. from pyspark.sql.functions import col # Single column cast df = df.withColumn(\"column_name\", col(\"column_name\").cast(\"target_data_type\")) # Multiple columns cast with select cast_expr = [ col(\"column1_name\").cast(\"target_data_type1\"), col(\"column2_name\").cast(\"target_data_type2\"), # More columns and data types as needed ] df = df.select(*cast_expr) Example Let’s create a dataset and apply cast() to change the data types of multiple columns:\nfrom pyspark.sql import SparkSession from pyspark.sql.functions import col from pyspark.sql.types import StructType, StructField, StringType, IntegerType, FloatType # Initialize Spark session spark = SparkSession.builder.appName(\"CastExample\").getOrCreate() # Define the schema for the dataset schema = StructType([ StructField(\"name\", StringType(), True), StructField(\"age\", StringType(), True), # Stored as StringType initially StructField(\"height\", StringType(), True) # Stored as StringType initially ]) # Create a sample dataset data = [ (\"Alice\", \"25\", \"5.5\"), (\"Bob\", \"35\", \"6.1\"), (\"Charlie\", \"40\", \"5.8\"), ] # Create DataFrame df = spark.createDataFrame(data, schema) # Show schema and data before casting df.printSchema() df.show() # Define cast expressions for multiple columns cast_expr = [ col(\"name\").cast(\"string\"), col(\"age\").cast(\"int\"), # Casting age to IntegerType col(\"height\").cast(\"double\") # Casting height to DoubleType ] # Apply the cast expressions to the DataFrame df = df.select(*cast_expr) # Show the result df.printSchema() df.show() Explanation age column: Initially stored as StringType, it’s cast to IntegerType (or \"int\"). height column: Initially stored as StringType, it’s cast to DoubleType (or \"double\"). Advantages of Using cast() Schema Alignment: Ensures data types in different tables or DataFrames are compatible for joining or union operations. Data Consistency: Ensures all columns conform to expected data types for downstream data processing. Error Reduction: Minimizes issues arising from mismatched data types in computations or transformations. This approach using cast() provides a flexible and powerful way to manage data types in PySpark.\nprintSchema() Method in PySpark Purpose:\nTo display the schema of a DataFrame, which includes the column names, data types, and nullability of each column. Output Structure:\nThe schema is presented in a tree-like structure showing:\nColumn Name: The name of the column. Data Type: The data type of the column (e.g., string, integer, double, boolean, etc.). Nullability: Indicates whether the column can contain null values (e.g., nullable = true). Usage:\nCall df.printSchema() on a DataFrame df to see its structure. Useful for verifying the structure of the DataFrame after operations like select(), withColumn(), or cast(). union and unionAll Overview Purpose: Both union and unionAll are used to combine two DataFrames into a single DataFrame. DataFrame Compatibility: The two DataFrames must have the same schema (i.e., the same column names and data types) to perform the union operation. union() Functionality:\nCombines two DataFrames and retains all rows, including duplicates. Behavior:\nThe union() method does not remove duplicate rows, resulting in a DataFrame that may contain duplicates. unionAll() Functionality:\nCombines two DataFrames and retains all rows, including duplicates. Behavior:\nThe unionAll() method performs the union operation but does not eliminate duplicate rows (similar to union). Syntax # Using union to retain all rows including duplicates unioned_df = df1.union(df2) # Using unionAll to retain all rows including duplicates unionAll_df = df1.unionAll(df2) Example: Using union and unionAll in PySpark from pyspark.sql import SparkSession # Initialize Spark session spark = SparkSession.builder.appName(\"UnionExample\").getOrCreate() # Sample DataFrames data1 = [(\"Alice\", 25), (\"Bob\", 30), (\"Charlie\", 35)] data2 = [(\"David\", 40), (\"Eve\", 45), (\"Alice\", 25)] columns = [\"name\", \"age\"] df1 = spark.createDataFrame(data1, columns) df2 = spark.createDataFrame(data2, columns) # Using union to retain all rows including duplicates unioned_df = df1.union(df2) # Using unionAll to retain all rows unionAll_df = df1.unionAll(df2) # Show the results print(\"unioned_df (No duplicates removed):\") unioned_df.show() print(\"unionAll_df (duplicates retained):\") unionAll_df.show() ## Removing Duplicate Rows in PySpark # Remove duplicate rows and create a new DataFrame unique_df = unioned_df.dropDuplicates() # or unique_df = unioned_df.distinct() print(\"unique_df (after removing duplicates):\") unique_df.show() Union and UnionByName In PySpark, both union and unionByName are operations that allow you to combine two or more DataFrames. However, they do this in slightly different ways, particularly regarding how they handle column names.\n1. union Definition:\nThe union() function is used to combine two DataFrames with the same schema (i.e., the same number of columns with the same data types).\nIt appends the rows of one DataFrame to the other.\nKey Characteristics:\nThe DataFrames must have the same number of columns. The columns must have compatible data types. It does not automatically handle column names that differ between DataFrames. Syntax DataFrame.union(otherDataFrame) from pyspark.sql import SparkSession # Create a Spark session spark = SparkSession.builder.appName(\"Union Example\").getOrCreate() # Create two DataFrames with the same schema data1 = [(\"Alice\", 1), (\"Bob\", 2)] data2 = [(\"Cathy\", 3), (\"David\", 4)] columns = [\"Name\", \"Id\"] df1 = spark.createDataFrame(data1, columns) df2 = spark.createDataFrame(data2, columns) # Perform union result_union = df1.union(df2) # Show the result result_union.show() 2. unionByName Definition:\nThe unionByName() function allows you to combine two DataFrames by matching column names.\nIf the DataFrames do not have the same schema, it will fill in missing columns with null.\nKey Characteristics:\nMatches DataFrames by column names rather than position. If the DataFrames have different columns, it will include all columns and fill in null for missing values in any DataFrame. You can specify allowMissingColumns=True to ignore missing columns. Syntax DataFrame.unionByName(otherDataFrame, allowMissingColumns=False) # Create two DataFrames with different schemas data3 = [(\"Eve\", 5), (\"Frank\", 6)] data4 = [(\"Grace\", \"New York\"), (\"Hannah\", \"Los Angeles\")] columns1 = [\"Name\", \"Id\"] columns2 = [\"Name\", \"City\"] df3 = spark.createDataFrame(data3, columns1) df4 = spark.createDataFrame(data4, columns2) # Perform unionByName (with allowMissingColumns=True to handle schema differences) result_union_by_name = df3.unionByName(df4, allowMissingColumns=True) # Show the result result_union_by_name.show() result_union_by_name.show() Summary of Differences union(): Requires DataFrames to have the same schema (same number of columns and compatible data types). It combines rows without checking column names. unionByName(): Matches DataFrames by column names. It can handle different schemas and fill missing columns with null (when allowMissingColumns=True). Feature Union UnionByName Column Matching Positional By Name Missing Columns Handling Does not allow Allows with null for missing Schema Requirement Must be identical Can differ Conclusion In PySpark:\nUse union() when you have DataFrames with the same schema and need a straightforward concatenation. Use unionByName() when your DataFrames have different schemas and you want to combine them by matching column names while handling missing columns.",
    "description": "when and otherwise The when and otherwise functions in PySpark provide a way to create conditional expressions within a DataFrame, allowing you to specify different values for new or existing columns based on specific conditions.\nwhen:\nThe when function in PySpark is used to define a condition.\nIf the condition is met, it returns the specified value.\nYou can chain multiple when conditions to handle various cases.\notherwise:\nThe otherwise function specifies a default value to return if none of the conditions in the when statements are met.",
    "tags": [],
    "title": "When|Cast|Union",
    "uri": "/azure_data_bricks/casewhen/"
  }
]
