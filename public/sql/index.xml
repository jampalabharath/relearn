<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SQL :: Data Engineering Notes</title>
    <link>http://localhost:1313/sql/</link>
    <description>Course Content 1. Introduction What is SQL? Types of Databases (Relational vs Non-Relational) SQL vs NoSQL SQL Standards (ANSI SQL, T-SQL, PL/SQL, MySQL SQL, PostgreSQL SQL) 2. SQL Basics Database, Schema, Table Data Types (Numeric, String, Date/Time, Boolean, JSON, XML) CREATE, DROP, ALTER INSERT, UPDATE, DELETE SELECT Statement WHERE Clause ORDER BY LIMIT / TOP / FETCH 3. Filtering &amp; Operators Comparison Operators Logical Operators (AND, OR, NOT) BETWEEN, IN, LIKE IS NULL / IS NOT NULL Pattern Matching (Wildcards, Regex) 4. Functions String Functions (CONCAT, SUBSTRING, TRIM, UPPER, LOWER, LENGTH) Numeric Functions (ROUND, CEIL, FLOOR, ABS, MOD) Date/Time Functions (NOW, DATEADD, DATEDIFF, FORMAT) Conversion Functions (CAST, CONVERT) Aggregate Functions (COUNT, SUM, AVG, MIN, MAX) 5. Joins INNER JOIN LEFT JOIN RIGHT JOIN FULL OUTER JOIN CROSS JOIN SELF JOIN USING vs ON 6. Subqueries &amp; Nested Queries Scalar Subqueries Table Subqueries Correlated Subqueries EXISTS / NOT EXISTS IN / ANY / ALL 7. Set Operations UNION vs UNION ALL INTERSECT EXCEPT / MINUS 8. Grouping &amp; Aggregation GROUP BY HAVING GROUPING SETS ROLLUP CUBE 9. Constraints &amp; Keys Primary Key Foreign Key Unique Key Check Constraint Default Constraint Not Null 10. Indexing &amp; Performance Clustered vs Non-Clustered Index Composite Index Covering Index Index Maintenance Query Execution Plans SQL Performance Tuning 11. Transactions BEGIN, COMMIT, ROLLBACK Savepoints ACID Properties Isolation Levels (Read Uncommitted, Read Committed, Repeatable Read, Serializable, Snapshot) Deadlocks &amp; Locking 12. Views &amp; Materialized Views Creating Views Updatable Views Indexed Views Materialized Views Refresh Strategies 13. Stored Procedures &amp; Functions User-Defined Functions (Scalar, Table-Valued) Stored Procedures Parameters (IN, OUT, INOUT) Error Handling in Procedures Recursive Procedures Dynamic SQL 14. Triggers AFTER Trigger INSTEAD OF Trigger Row-level vs Statement-level Triggers Use Cases 15. Advanced SQL Window Functions (ROW_NUMBER, RANK, DENSE_RANK, NTILE) LAG &amp; LEAD FIRST_VALUE &amp; LAST_VALUE Common Table Expressions (CTEs) Recursive CTEs Pivoting and Unpivoting JSON &amp; XML in SQL Hierarchical Queries Full-Text Search 16. Security Users &amp; Roles GRANT, REVOKE, DENY Row-Level Security Column-Level Security Data Masking Encryption at Rest &amp; In-Transit 17. Advanced Database Concepts Normalization &amp; Denormalization Star &amp; Snowflake Schema Partitioning (Horizontal, Vertical) Sharding Federation Replication High Availability &amp; Failover 18. SQL with Big Data SQL on Hadoop / Hive Spark SQL SQL in Cloud Platforms (AWS Athena, BigQuery, Azure Synapse) 19. SQL in Practice Data Warehousing with SQL ETL using SQL Reporting Queries Performance Benchmarking Debugging Complex Queries 20. Capstone Project Design &amp; Implement Normalized Database Build ETL Pipeline using SQL Create Analytical Queries &amp; Reports Optimize Large-Scale SQL Workloads</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/sql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SELECT Query</title>
      <link>http://localhost:1313/sql/select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/select/</guid>
      <description>This guide covers various SELECT query techniques used for retrieving, filtering, sorting, and aggregating data efficiently.&#xA;Comments -- This is a single-line comment. /* This is a multiple-line comment */ 1. SELECT ALL COLUMNS -- Retrieve All Customer Data SELECT * FROM customers; -- Retrieve All Order Data SELECT * FROM orders; 2. SELECT SPECIFIC COLUMNS -- Retrieve each customer&#39;s name, country, and score SELECT first_name, country, score FROM customers; 3. WHERE CLAUSE -- Retrieve customers with a score not equal to 0 SELECT * FROM customers WHERE score != 0; -- Retrieve customers from Germany SELECT * FROM customers WHERE country = &#39;Germany&#39;; -- Retrieve the name and country of customers from Germany SELECT first_name, country FROM customers WHERE country = &#39;Germany&#39;; 4. ORDER BY -- Sort by highest score first SELECT * FROM customers ORDER BY score DESC; -- Sort by lowest score first SELECT * FROM customers ORDER BY score ASC; -- Sort by country SELECT * FROM customers ORDER BY country ASC; -- Sort by country, then highest score SELECT * FROM customers ORDER BY country ASC, score DESC; -- Customers with score != 0, sorted by highest score SELECT first_name, country, score FROM customers WHERE score != 0 ORDER BY score DESC; 5. GROUP BY -- Find total score for each country SELECT country, SUM(score) AS total_score FROM customers GROUP BY country; -- ❌ Invalid: first_name not grouped or aggregated SELECT country, first_name, SUM(score) AS total_score FROM customers GROUP BY country; -- Find total score &amp; number of customers per country SELECT country, SUM(score) AS total_score, COUNT(id) AS total_customers FROM customers GROUP BY country; 6. HAVING -- Average score &gt; 430 for each country SELECT country, AVG(score) AS avg_score FROM customers GROUP BY country HAVING AVG(score) &gt; 430; -- Only consider customers with score != 0 SELECT country, AVG(score) AS avg_score FROM customers WHERE score != 0 GROUP BY country HAVING AVG(score) &gt; 430; 7. DISTINCT -- Unique list of countries SELECT DISTINCT country FROM customers; 8. TOP -- Retrieve only 3 customers SELECT TOP 3 * FROM customers; -- Top 3 customers with highest scores SELECT TOP 3 * FROM customers ORDER BY score DESC; -- Lowest 2 customers by score SELECT TOP 2 * FROM customers ORDER BY score ASC; -- Two most recent orders SELECT TOP 2 * FROM orders ORDER BY order_date DESC; 9. All Together -- Average score per country, excluding score=0, -- only &gt; 430, ordered by highest avg_score SELECT country, AVG(score) AS avg_score FROM customers WHERE score != 0 GROUP BY country HAVING AVG(score) &gt; 430 ORDER BY AVG(score) DESC; 10. COOL STUFF – Additional SQL Features -- Execute multiple queries at once SELECT * FROM customers; SELECT * FROM orders; -- Select static values SELECT 123 AS static_number; SELECT &#39;Hello&#39; AS static_string; -- Assign a constant value in query results SELECT id, first_name, &#39;New Customer&#39; AS customer_type FROM customers;</description>
    </item>
    <item>
      <title>DDL</title>
      <link>http://localhost:1313/sql/ddl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/ddl/</guid>
      <description>This guide covers the essential DDL (Data Definition Language) commands used for defining and managing database structures, including creating, modifying, and deleting tables.&#xA;1. CREATE – Creating Tables -- Create a new table called persons -- with columns: id, person_name, birth_date, and phone CREATE TABLE persons ( id INT NOT NULL, person_name VARCHAR(50) NOT NULL, birth_date DATE, phone VARCHAR(15) NOT NULL, CONSTRAINT pk_persons PRIMARY KEY (id) ); 2. ALTER – Modifying Table Structure -- Add a new column called email to the persons table ALTER TABLE persons ADD email VARCHAR(50) NOT NULL; -- Remove the column phone from the persons table ALTER TABLE persons DROP COLUMN phone; 3. DROP – Removing Tables -- Delete the table persons from the database DROP TABLE persons;</description>
    </item>
    <item>
      <title>DML</title>
      <link>http://localhost:1313/sql/dml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/dml/</guid>
      <description>This guide covers the essential DML (Data Manipulation Language) commands used for inserting, updating, and deleting data in database tables.&#xA;1. INSERT – Adding Data to Tables Method 1: Manual INSERT using VALUES -- Insert new records into the customers table INSERT INTO customers (id, first_name, country, score) VALUES (6, &#39;Anna&#39;, &#39;USA&#39;, NULL), (7, &#39;Sam&#39;, NULL, 100); -- Incorrect column order INSERT INTO customers (id, first_name, country, score) VALUES (8, &#39;Max&#39;, &#39;USA&#39;, NULL); -- Incorrect data type in values INSERT INTO customers (id, first_name, country, score) VALUES (&#39;Max&#39;, 9, &#39;Max&#39;, NULL); -- Insert a new record with full column values INSERT INTO customers (id, first_name, country, score) VALUES (8, &#39;Max&#39;, &#39;USA&#39;, 368); -- Insert without specifying column names (not recommended) INSERT INTO customers VALUES (9, &#39;Andreas&#39;, &#39;Germany&#39;, NULL); -- Insert a record with only id and first_name INSERT INTO customers (id, first_name) VALUES (10, &#39;Sahra&#39;); Method 2: INSERT using SELECT (Copying Data) -- Copy data from customers table into persons INSERT INTO persons (id, person_name, birth_date, phone) SELECT id, first_name, NULL, &#39;Unknown&#39; FROM customers; 2. UPDATE – Modifying Existing Data -- Change the score of customer with ID 6 to 0 UPDATE customers SET score = 0 WHERE id = 6; -- Change score and country for customer with ID 10 UPDATE customers SET score = 0, country = &#39;UK&#39; WHERE id = 10; -- Update all NULL scores to 0 UPDATE customers SET score = 0 WHERE score IS NULL; -- Verify the update SELECT * FROM customers WHERE score IS NULL; 3. DELETE – Removing Data from Tables -- Select customers with ID greater than 5 SELECT * FROM customers WHERE id &gt; 5; -- Delete customers with ID greater than 5 DELETE FROM customers WHERE id &gt; 5; -- Delete all rows from persons DELETE FROM persons; -- Faster method to delete all rows TRUNCATE TABLE persons;</description>
    </item>
    <item>
      <title>Filtering Data</title>
      <link>http://localhost:1313/sql/filter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/filter/</guid>
      <description>This document provides an overview of SQL filtering techniques using WHERE and various operators for precise data retrieval.&#xA;1. Comparison Operators (=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=) -- Retrieve all customers from Germany SELECT * FROM customers WHERE country = &#39;Germany&#39;; -- Retrieve all customers who are not from Germany SELECT * FROM customers WHERE country &lt;&gt; &#39;Germany&#39;; -- Retrieve all customers with a score greater than 500 SELECT * FROM customers WHERE score &gt; 500; -- Retrieve all customers with a score of 500 or more SELECT * FROM customers WHERE score &gt;= 500; -- Retrieve all customers with a score less than 500 SELECT * FROM customers WHERE score &lt; 500; -- Retrieve all customers with a score of 500 or less SELECT * FROM customers WHERE score &lt;= 500; 2. Logical Operators (AND, OR, NOT) -- Customers from the USA and score &gt; 500 SELECT * FROM customers WHERE country = &#39;USA&#39; AND score &gt; 500; -- Customers from the USA or score &gt; 500 SELECT * FROM customers WHERE country = &#39;USA&#39; OR score &gt; 500; -- Customers with score not less than 500 SELECT * FROM customers WHERE NOT score &lt; 500; 3. Range Filtering – BETWEEN -- Customers with score between 100 and 500 SELECT * FROM customers WHERE score BETWEEN 100 AND 500; -- Equivalent to BETWEEN SELECT * FROM customers WHERE score &gt;= 100 AND score &lt;= 500; 4. Set Filtering – IN -- Customers from Germany or USA SELECT * FROM customers WHERE country IN (&#39;Germany&#39;, &#39;USA&#39;); 5. Pattern Matching – LIKE -- First name starts with &#39;M&#39; SELECT * FROM customers WHERE first_name LIKE &#39;M%&#39;; -- First name ends with &#39;n&#39; SELECT * FROM customers WHERE first_name LIKE &#39;%n&#39;; -- First name contains &#39;r&#39; SELECT * FROM customers WHERE first_name LIKE &#39;%r%&#39;; -- First name has &#39;r&#39; in the third position SELECT * FROM customers WHERE first_name LIKE &#39;__r%&#39;;</description>
    </item>
    <item>
      <title>Joins</title>
      <link>http://localhost:1313/sql/joins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/joins/</guid>
      <description>This document provides an overview of SQL Joins, which allow combining data from multiple tables to retrieve meaningful insights.&#xA;1. Basic Joins No Join -- Retrieve all data from customers and orders as separate results SELECT * FROM customers; SELECT * FROM orders; INNER JOIN -- Get all customers along with their orders (only those who placed an order) SELECT c.id, c.first_name, o.order_id, o.sales FROM customers AS c INNER JOIN orders AS o ON c.id = o.customer_id; LEFT JOIN -- Get all customers along with their orders (including customers without orders) SELECT c.id, c.first_name, o.order_id, o.sales FROM customers AS c LEFT JOIN orders AS o ON c.id = o.customer_id; RIGHT JOIN -- Get all customers along with their orders (including orders without customers) SELECT c.id, c.first_name, o.order_id, o.customer_id, o.sales FROM customers AS c RIGHT JOIN orders AS o ON c.id = o.customer_id; Alternative to RIGHT JOIN (using LEFT JOIN) SELECT c.id, c.first_name, o.order_id, o.sales FROM orders AS o LEFT JOIN customers AS c ON c.id = o.customer_id; FULL JOIN -- Get all customers and all orders, even if there’s no match SELECT c.id, c.first_name, o.order_id, o.customer_id, o.sales FROM customers AS c FULL JOIN orders AS o ON c.id = o.customer_id; 2. Advanced Joins LEFT ANTI JOIN -- Customers who haven&#39;t placed any order SELECT * FROM customers AS c LEFT JOIN orders AS o ON c.id = o.customer_id WHERE o.customer_id IS NULL; RIGHT ANTI JOIN -- Orders without matching customers SELECT * FROM customers AS c RIGHT JOIN orders AS o ON c.id = o.customer_id WHERE c.id IS NULL; Alternative to RIGHT ANTI JOIN (using LEFT JOIN) SELECT * FROM orders AS o LEFT JOIN customers AS c ON c.id = o.customer_id WHERE c.id IS NULL; Alternative to INNER JOIN (using LEFT JOIN) SELECT * FROM customers AS c LEFT JOIN orders AS o ON c.id = o.customer_id WHERE o.customer_id IS NOT NULL; FULL ANTI JOIN -- Find customers without orders and orders without customers SELECT c.id, c.first_name, o.order_id, o.customer_id, o.sales FROM customers AS c FULL JOIN orders AS o ON c.id = o.customer_id WHERE o.customer_id IS NULL OR c.id IS NULL; CROSS JOIN -- Generate all possible combinations of customers and orders SELECT * FROM customers CROSS JOIN orders; 3. Multiple Table Joins (4 Tables) Task: Using SalesDB, retrieve a list of all orders along with related customer, product, and employee details. For each order, display:</description>
    </item>
    <item>
      <title>Set Operations</title>
      <link>http://localhost:1313/sql/set-operations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/set-operations/</guid>
      <description>SQL set operations enable you to combine results from multiple queries into a single result set.&#xA;This guide demonstrates the rules and usage of UNION, UNION ALL, EXCEPT, and INTERSECT.&#xA;1. SQL Operation Rules Rule: Data Types The data types of columns in each query should match.&#xA;SELECT FirstName, LastName, Country FROM Sales.Customers UNION SELECT FirstName, LastName FROM Sales.Employees; Rule: Data Types (Example) SELECT CustomerID, LastName FROM Sales.Customers UNION SELECT FirstName, LastName FROM Sales.Employees; Rule: Column Order The order of the columns in each query must be the same.</description>
    </item>
    <item>
      <title>String Functions</title>
      <link>http://localhost:1313/sql/string-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/string-functions/</guid>
      <description>This document provides an overview of SQL string functions, which allow manipulation, transformation, and extraction of text data efficiently.&#xA;1. Manipulations CONCAT() – String Concatenation -- Concatenate first name and country into one column SELECT CONCAT(first_name, &#39;-&#39;, country) AS full_info FROM customers; LOWER() &amp; UPPER() – Case Transformation -- Convert the first name to lowercase SELECT LOWER(first_name) AS lower_case_name FROM customers; -- Convert the first name to uppercase SELECT UPPER(first_name) AS upper_case_name FROM customers; TRIM() – Remove White Spaces -- Find customers whose first name contains leading or trailing spaces SELECT first_name, LEN(first_name) AS len_name, LEN(TRIM(first_name)) AS len_trim_name, LEN(first_name) - LEN(TRIM(first_name)) AS flag FROM customers WHERE LEN(first_name) != LEN(TRIM(first_name)); -- Alternative: -- WHERE first_name != TRIM(first_name) REPLACE() – Replace or Remove Values -- Remove dashes (-) from a phone number SELECT &#39;123-456-7890&#39; AS phone, REPLACE(&#39;123-456-7890&#39;, &#39;-&#39;, &#39;/&#39;) AS clean_phone; -- Replace file extension from .txt to .csv SELECT &#39;report.txt&#39; AS old_filename, REPLACE(&#39;report.txt&#39;, &#39;.txt&#39;, &#39;.csv&#39;) AS new_filename; 2. Calculation LEN() – String Length -- Calculate the length of each customer&#39;s first name SELECT first_name, LEN(first_name) AS name_length FROM customers; 3. Substring Extraction LEFT() &amp; RIGHT() -- Retrieve the first two characters of each first name SELECT first_name, LEFT(TRIM(first_name), 2) AS first_2_chars FROM customers; -- Retrieve the last two characters of each first name SELECT first_name, RIGHT(first_name, 2) AS last_2_chars FROM customers; SUBSTRING() -- Retrieve a list of customers&#39; first names after removing the first character SELECT first_name, SUBSTRING(TRIM(first_name), 2, LEN(first_name)) AS trimmed_name FROM customers; 4. Nesting Functions – Nesting example SELECT first_name, UPPER(LOWER(first_name)) AS nesting FROM customers;</description>
    </item>
    <item>
      <title>Number Functions</title>
      <link>http://localhost:1313/sql/number-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/number-functions/</guid>
      <description>This document provides an overview of SQL number functions, which allow performing mathematical operations and formatting numerical values.&#xA;1. Rounding Functions ROUND() – Rounding Numbers -- Demonstrate rounding a number to different decimal places SELECT 3.516 AS original_number, ROUND(3.516, 2) AS round_2, ROUND(3.516, 1) AS round_1, ROUND(3.516, 0) AS round_0; 2. Absolute Value Function ABS() – Absolute Value -- Demonstrate absolute value function SELECT -10 AS original_number, ABS(-10) AS absolute_value_negative, ABS(10) AS absolute_value_positive;</description>
    </item>
    <item>
      <title>Date &amp; Time Functions</title>
      <link>http://localhost:1313/sql/date-time1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/date-time1/</guid>
      <description>This guide demonstrates various date and time functions in SQL.&#xA;It covers GETDATE, DATETRUNC, DATENAME, DATEPART, YEAR, MONTH, DAY, EOMONTH, FORMAT, CONVERT, CAST, DATEADD, DATEDIFF, and ISDATE.&#xA;1. GETDATE() | Date Values -- Display OrderID, CreationTime, a hard-coded date, and the current system date SELECT OrderID, CreationTime, &#39;2025-08-20&#39; AS HardCoded, GETDATE() AS Today FROM Sales.Orders; 2. Date Part Extractions (DATETRUNC, DATENAME, DATEPART, YEAR, MONTH, DAY) -- Extract various parts of CreationTime SELECT OrderID, CreationTime, DATETRUNC(year, CreationTime) AS Year_dt, DATETRUNC(day, CreationTime) AS Day_dt, DATETRUNC(minute, CreationTime) AS Minute_dt, DATENAME(month, CreationTime) AS Month_dn, DATENAME(weekday, CreationTime) AS Weekday_dn, DATENAME(day, CreationTime) AS Day_dn, DATENAME(year, CreationTime) AS Year_dn, DATEPART(year, CreationTime) AS Year_dp, DATEPART(month, CreationTime) AS Month_dp, DATEPART(day, CreationTime) AS Day_dp, DATEPART(hour, CreationTime) AS Hour_dp, DATEPART(quarter, CreationTime) AS Quarter_dp, DATEPART(week, CreationTime) AS Week_dp, YEAR(CreationTime) AS Year, MONTH(CreationTime) AS Month, DAY(CreationTime) AS Day FROM Sales.Orders; 3. DATETRUNC() Data Aggregation -- Aggregate orders by year SELECT DATETRUNC(year, CreationTime) AS Creation, COUNT(*) AS OrderCount FROM Sales.Orders GROUP BY DATETRUNC(year, CreationTime); 4. EOMONTH() -- Display end-of-month date for each order SELECT OrderID, CreationTime, EOMONTH(CreationTime) AS EndOfMonth FROM Sales.Orders; 5. Date Parts | Use Cases -- Orders per year SELECT YEAR(OrderDate) AS OrderYear, COUNT(*) AS TotalOrders FROM Sales.Orders GROUP BY YEAR(OrderDate); -- Orders per month SELECT MONTH(OrderDate) AS OrderMonth, COUNT(*) AS TotalOrders FROM Sales.Orders GROUP BY MONTH(OrderDate); -- Orders per month (friendly names) SELECT DATENAME(month, OrderDate) AS OrderMonth, COUNT(*) AS TotalOrders FROM Sales.Orders GROUP BY DATENAME(month, OrderDate); -- Orders placed in February SELECT * FROM Sales.Orders WHERE MONTH(OrderDate) = 2; 6. FORMAT() -- Format CreationTime into different formats SELECT OrderID, CreationTime, FORMAT(CreationTime, &#39;MM-dd-yyyy&#39;) AS USA_Format, FORMAT(CreationTime, &#39;dd-MM-yyyy&#39;) AS EURO_Format, FORMAT(CreationTime, &#39;dd&#39;) AS dd, FORMAT(CreationTime, &#39;ddd&#39;) AS ddd, FORMAT(CreationTime, &#39;dddd&#39;) AS dddd, FORMAT(CreationTime, &#39;MM&#39;) AS MM, FORMAT(CreationTime, &#39;MMM&#39;) AS MMM, FORMAT(CreationTime, &#39;MMMM&#39;) AS MMMM FROM Sales.Orders; -- Custom format example SELECT OrderID, CreationTime, &#39;Day &#39; + FORMAT(CreationTime, &#39;ddd MMM&#39;) + &#39; Q&#39; + DATENAME(quarter, CreationTime) + &#39; &#39; + FORMAT(CreationTime, &#39;yyyy hh:mm:ss tt&#39;) AS CustomFormat FROM Sales.Orders; -- Orders per month (formatted &#34;MMM yy&#34;) SELECT FORMAT(CreationTime, &#39;MMM yy&#39;) AS OrderDate, COUNT(*) AS TotalOrders FROM Sales.Orders GROUP BY FORMAT(CreationTime, &#39;MMM yy&#39;); 7. CONVERT() -- Conversion using CONVERT SELECT CONVERT(INT, &#39;123&#39;) AS [String to Int CONVERT], CONVERT(DATE, &#39;2025-08-20&#39;) AS [String to Date CONVERT], CreationTime, CONVERT(DATE, CreationTime) AS [Datetime to Date CONVERT], CONVERT(VARCHAR, CreationTime, 32) AS [USA Std. Style:32], CONVERT(VARCHAR, CreationTime, 34) AS [EURO Std. Style:34] FROM Sales.Orders; 8. CAST() -- Conversion using CAST SELECT CAST(&#39;123&#39; AS INT) AS [String to Int], CAST(123 AS VARCHAR) AS [Int to String], CAST(&#39;2025-08-20&#39; AS DATE) AS [String to Date], CAST(&#39;2025-08-20&#39; AS DATETIME2) AS [String to Datetime], CreationTime, CAST(CreationTime AS DATE) AS [Datetime to Date] FROM Sales.Orders; 9. DATEADD / DATEDIFF -- Date arithmetic SELECT OrderID, OrderDate, DATEADD(day, -10, OrderDate) AS TenDaysBefore, DATEADD(month, 3, OrderDate) AS ThreeMonthsLater, DATEADD(year, 2, OrderDate) AS TwoYearsLater FROM Sales.Orders; -- Employee ages SELECT EmployeeID, BirthDate, DATEDIFF(year, BirthDate, GETDATE()) AS Age FROM Sales.Employees; -- Avg shipping duration SELECT MONTH(OrderDate) AS OrderMonth, AVG(DATEDIFF(day, OrderDate, ShipDate)) AS AvgShip FROM Sales.Orders GROUP BY MONTH(OrderDate); -- Time gap analysis SELECT OrderID, OrderDate AS CurrentOrderDate, LAG(OrderDate) OVER (ORDER BY OrderDate) AS PreviousOrderDate, DATEDIFF(day, LAG(OrderDate) OVER (ORDER BY OrderDate), OrderDate) AS NrOfDays FROM Sales.Orders; 10. ISDATE() -- Validate OrderDate using ISDATE SELECT OrderDate, ISDATE(OrderDate) AS IsValidDate, CASE WHEN ISDATE(OrderDate) = 1 THEN CAST(OrderDate AS DATE) ELSE &#39;9999-01-01&#39; END AS NewOrderDate FROM ( SELECT &#39;2025-08-20&#39; AS OrderDate UNION SELECT &#39;2025-08-21&#39; UNION SELECT &#39;2025-08-23&#39; UNION SELECT &#39;2025-08&#39; ) AS t; -- WHERE ISDATE(OrderDate) = 0</description>
    </item>
    <item>
      <title>Date &amp; Time Formats</title>
      <link>http://localhost:1313/sql/date-time2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/date-time2/</guid>
      <description>This guide demonstrates all possible date parts, number formats, and culture-specific styles available in SQL Server.&#xA;1. Numeric Format Specifiers SELECT &#39;N&#39; AS FormatType, FORMAT(1234.56, &#39;N&#39;) AS FormattedValue UNION ALL SELECT &#39;P&#39;, FORMAT(1234.56, &#39;P&#39;) UNION ALL SELECT &#39;C&#39;, FORMAT(1234.56, &#39;C&#39;) UNION ALL SELECT &#39;E&#39;, FORMAT(1234.56, &#39;E&#39;) UNION ALL SELECT &#39;F&#39;, FORMAT(1234.56, &#39;F&#39;) UNION ALL SELECT &#39;N0&#39;, FORMAT(1234.56, &#39;N0&#39;) UNION ALL SELECT &#39;N1&#39;, FORMAT(1234.56, &#39;N1&#39;) UNION ALL SELECT &#39;N2&#39;, FORMAT(1234.56, &#39;N2&#39;) UNION ALL SELECT &#39;N_de-DE&#39;, FORMAT(1234.56, &#39;N&#39;, &#39;de-DE&#39;) UNION ALL SELECT &#39;N_en-US&#39;, FORMAT(1234.56, &#39;N&#39;, &#39;en-US&#39;); 2. Date Format Specifiers SELECT &#39;D&#39; AS FormatType, FORMAT(GETDATE(), &#39;D&#39;) AS FormattedValue, &#39;Full date pattern&#39; AS Description UNION ALL SELECT &#39;d&#39;, FORMAT(GETDATE(), &#39;d&#39;), &#39;Short date pattern&#39; UNION ALL SELECT &#39;dd&#39;, FORMAT(GETDATE(), &#39;dd&#39;), &#39;Day of month with leading zero&#39; UNION ALL SELECT &#39;ddd&#39;, FORMAT(GETDATE(), &#39;ddd&#39;), &#39;Abbreviated name of day&#39; UNION ALL SELECT &#39;dddd&#39;, FORMAT(GETDATE(), &#39;dddd&#39;), &#39;Full name of day&#39; UNION ALL SELECT &#39;M&#39;, FORMAT(GETDATE(), &#39;M&#39;), &#39;Month without leading zero&#39; UNION ALL SELECT &#39;MM&#39;, FORMAT(GETDATE(), &#39;MM&#39;), &#39;Month with leading zero&#39; UNION ALL SELECT &#39;MMM&#39;, FORMAT(GETDATE(), &#39;MMM&#39;), &#39;Abbreviated name of month&#39; UNION ALL SELECT &#39;MMMM&#39;, FORMAT(GETDATE(), &#39;MMMM&#39;), &#39;Full name of month&#39; UNION ALL SELECT &#39;yy&#39;, FORMAT(GETDATE(), &#39;yy&#39;), &#39;Two-digit year&#39; UNION ALL SELECT &#39;yyyy&#39;, FORMAT(GETDATE(), &#39;yyyy&#39;), &#39;Four-digit year&#39; UNION ALL SELECT &#39;hh&#39;, FORMAT(GETDATE(), &#39;hh&#39;), &#39;12-hour clock with leading zero&#39; UNION ALL SELECT &#39;HH&#39;, FORMAT(GETDATE(), &#39;HH&#39;), &#39;24-hour clock with leading zero&#39; UNION ALL SELECT &#39;m&#39;, FORMAT(GETDATE(), &#39;m&#39;), &#39;Minutes without leading zero&#39; UNION ALL SELECT &#39;mm&#39;, FORMAT(GETDATE(), &#39;mm&#39;), &#39;Minutes with leading zero&#39; UNION ALL SELECT &#39;s&#39;, FORMAT(GETDATE(), &#39;s&#39;), &#39;Seconds without leading zero&#39; UNION ALL SELECT &#39;ss&#39;, FORMAT(GETDATE(), &#39;ss&#39;), &#39;Seconds with leading zero&#39; UNION ALL SELECT &#39;f&#39;, FORMAT(GETDATE(), &#39;f&#39;), &#39;Tenths of a second&#39; UNION ALL SELECT &#39;ff&#39;, FORMAT(GETDATE(), &#39;ff&#39;), &#39;Hundredths of a second&#39; UNION ALL SELECT &#39;fff&#39;, FORMAT(GETDATE(), &#39;fff&#39;), &#39;Milliseconds&#39; UNION ALL SELECT &#39;T&#39;, FORMAT(GETDATE(), &#39;T&#39;), &#39;Full AM/PM designator&#39; UNION ALL SELECT &#39;t&#39;, FORMAT(GETDATE(), &#39;t&#39;), &#39;Single char AM/PM designator&#39; UNION ALL SELECT &#39;tt&#39;, FORMAT(GETDATE(), &#39;tt&#39;), &#39;Two char AM/PM designator&#39;; 3. DatePart / DateName / DateTrunc Comparisons SELECT &#39;Year&#39; AS DatePart, DATEPART(year, GETDATE()), DATENAME(year, GETDATE()), DATETRUNC(year, GETDATE()) UNION ALL SELECT &#39;Quarter&#39;, DATEPART(quarter, GETDATE()), DATENAME(quarter, GETDATE()), DATETRUNC(quarter, GETDATE()) UNION ALL SELECT &#39;Month&#39;, DATEPART(month, GETDATE()), DATENAME(month, GETDATE()), DATETRUNC(month, GETDATE()) UNION ALL SELECT &#39;DayOfYear&#39;, DATEPART(dayofyear, GETDATE()), DATENAME(dayofyear, GETDATE()), DATETRUNC(dayofyear, GETDATE()) UNION ALL SELECT &#39;Day&#39;, DATEPART(day, GETDATE()), DATENAME(day, GETDATE()), DATETRUNC(day, GETDATE()) UNION ALL SELECT &#39;Week&#39;, DATEPART(week, GETDATE()), DATENAME(week, GETDATE()), DATETRUNC(week, GETDATE()) UNION ALL SELECT &#39;Weekday&#39;, DATEPART(weekday, GETDATE()), DATENAME(weekday, GETDATE()), NULL UNION ALL SELECT &#39;Hour&#39;, DATEPART(hour, GETDATE()), DATENAME(hour, GETDATE()), DATETRUNC(hour, GETDATE()) UNION ALL SELECT &#39;Minute&#39;, DATEPART(minute, GETDATE()), DATENAME(minute, GETDATE()), DATETRUNC(minute, GETDATE()) UNION ALL SELECT &#39;Second&#39;, DATEPART(second, GETDATE()), DATENAME(second, GETDATE()), DATETRUNC(second, GETDATE()) UNION ALL SELECT &#39;Millisecond&#39;, DATEPART(millisecond, GETDATE()), DATENAME(millisecond, GETDATE()), DATETRUNC(millisecond, GETDATE()) UNION ALL SELECT &#39;Microsecond&#39;, DATEPART(microsecond, GETDATE()), DATENAME(microsecond, GETDATE()), NULL UNION ALL SELECT &#39;Nanosecond&#39;, DATEPART(nanosecond, GETDATE()), DATENAME(nanosecond, GETDATE()), NULL UNION ALL SELECT &#39;ISOWeek&#39;, DATEPART(iso_week, GETDATE()), DATENAME(iso_week, GETDATE()), DATETRUNC(iso_week, GETDATE()); 4. Culture Code Formatting SELECT &#39;en-US&#39; AS CultureCode, FORMAT(1234567.89, &#39;N&#39;, &#39;en-US&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;en-US&#39;) UNION ALL SELECT &#39;en-GB&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;en-GB&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;en-GB&#39;) UNION ALL SELECT &#39;fr-FR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;fr-FR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;fr-FR&#39;) UNION ALL SELECT &#39;de-DE&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;de-DE&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;de-DE&#39;) UNION ALL SELECT &#39;es-ES&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;es-ES&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;es-ES&#39;) UNION ALL SELECT &#39;zh-CN&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;zh-CN&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;zh-CN&#39;) UNION ALL SELECT &#39;ja-JP&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;ja-JP&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;ja-JP&#39;) UNION ALL SELECT &#39;ko-KR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;ko-KR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;ko-KR&#39;) UNION ALL SELECT &#39;pt-BR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;pt-BR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;pt-BR&#39;) UNION ALL SELECT &#39;it-IT&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;it-IT&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;it-IT&#39;) UNION ALL SELECT &#39;nl-NL&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;nl-NL&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;nl-NL&#39;) UNION ALL SELECT &#39;ru-RU&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;ru-RU&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;ru-RU&#39;) UNION ALL SELECT &#39;ar-SA&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;ar-SA&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;ar-SA&#39;) UNION ALL SELECT &#39;el-GR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;el-GR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;el-GR&#39;) UNION ALL SELECT &#39;tr-TR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;tr-TR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;tr-TR&#39;) UNION ALL SELECT &#39;he-IL&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;he-IL&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;he-IL&#39;) UNION ALL SELECT &#39;hi-IN&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;hi-IN&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;hi-IN&#39;);</description>
    </item>
    <item>
      <title>NULL Functions</title>
      <link>http://localhost:1313/sql/null-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/null-functions/</guid>
      <description>This guide covers essential SQL functions for handling NULL values in different scenarios such as aggregation, mathematical operations, sorting, joins, and comparisons.&#xA;1. Handle NULL - Data Aggregation Replace NULL values using COALESCE to ensure accurate averages.&#xA;SELECT CustomerID, Score, COALESCE(Score, 0) AS Score2, AVG(Score) OVER () AS AvgScores, AVG(COALESCE(Score, 0)) OVER () AS AvgScores2 FROM Sales.Customers; 2. Handle NULL - Mathematical Operators Concatenate first and last names safely and add bonus points with COALESCE.</description>
    </item>
    <item>
      <title>CASE Statement</title>
      <link>http://localhost:1313/sql/case-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/case-statement/</guid>
      <description>1. Categorize Data Create sales categories based on value ranges.&#xA;SELECT Category, SUM(Sales) AS TotalSales FROM ( SELECT OrderID, Sales, CASE WHEN Sales &gt; 50 THEN &#39;High&#39; WHEN Sales &gt; 20 THEN &#39;Medium&#39; ELSE &#39;Low&#39; END AS Category FROM Sales.Orders ) AS t GROUP BY Category ORDER BY TotalSales DESC; 2. Mapping Map country names to abbreviations.&#xA;SELECT CustomerID, FirstName, LastName, Country, CASE WHEN Country = &#39;Germany&#39; THEN &#39;DE&#39; WHEN Country = &#39;USA&#39; THEN &#39;US&#39; ELSE &#39;n/a&#39; END AS CountryAbbr FROM Sales.Customers; 3. Quick Form of CASE Statement Use the shorthand CASE syntax for direct equality comparisons.</description>
    </item>
    <item>
      <title>Aggregate Functions</title>
      <link>http://localhost:1313/sql/aggregate-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/aggregate-functions/</guid>
      <description>SQL aggregate functions perform calculations on multiple rows of data and return summary results.&#xA;1. Basic Aggregate Functions COUNT – Count rows SELECT COUNT(*) AS total_customers FROM customers; SUM – Total of values SELECT SUM(sales) AS total_sales FROM orders; AVG – Average of values SELECT AVG(sales) AS avg_sales FROM orders; MAX – Maximum value SELECT MAX(score) AS max_score FROM customers; MIN – Minimum value SELECT MIN(score) AS min_score FROM customers; 2. Grouped Aggregations – GROUP BY Aggregate results per group.</description>
    </item>
    <item>
      <title>Window Functions</title>
      <link>http://localhost:1313/sql/window-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/window-functions/</guid>
      <description>SQL window functions enable advanced calculations across sets of rows related to the current row without needing complex subqueries or joins. They support clauses like OVER, PARTITION, ORDER, FRAME, along with important rules and group-based use cases.&#xA;Table of Contents SQL Window Basics SQL Window OVER Clause SQL Window PARTITION Clause SQL Window ORDER Clause SQL Window FRAME Clause SQL Window Rules SQL Window with GROUP BY 1. SQL Window Basics TASK 1 – Calculate the Total Sales Across All Orders SELECT SUM(Sales) AS Total_Sales FROM Sales.Orders; TASK 2 – Calculate the Total Sales for Each Product SELECT ProductID, SUM(Sales) AS Total_Sales FROM Sales.Orders GROUP BY ProductID; 2. SQL Window OVER Clause TASK 3 – Total sales across all orders with order details SELECT OrderID, OrderDate, ProductID, Sales, SUM(Sales) OVER () AS Total_Sales FROM Sales.Orders; 3. SQL Window PARTITION Clause TASK 4 – Total sales overall and per product SELECT OrderID, OrderDate, ProductID, Sales, SUM(Sales) OVER () AS Total_Sales, SUM(Sales) OVER (PARTITION BY ProductID) AS Sales_By_Product FROM Sales.Orders; TASK 5 – Total sales overall, per product, and per product-status combination SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER () AS Total_Sales, SUM(Sales) OVER (PARTITION BY ProductID) AS Sales_By_Product, SUM(Sales) OVER (PARTITION BY ProductID, OrderStatus) AS Sales_By_Product_Status FROM Sales.Orders; 4. SQL Window ORDER Clause TASK 6 – Rank each order by sales (highest to lowest) SELECT OrderID, OrderDate, Sales, RANK() OVER (ORDER BY Sales DESC) AS Rank_Sales FROM Sales.Orders; 5. SQL Window FRAME Clause TASK 7 – Total sales by order status (current + next two orders) SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING ) AS Total_Sales FROM Sales.Orders; TASK 8 – Total sales by order status (current + previous two orders) SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW ) AS Total_Sales FROM Sales.Orders; TASK 9 – Total sales by order status (previous two orders only) SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS 2 PRECEDING ) AS Total_Sales FROM Sales.Orders; TASK 10 – Cumulative sales up to the current order SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS Total_Sales FROM Sales.Orders; TASK 11 – Cumulative sales from start to current row SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS UNBOUNDED PRECEDING ) AS Total_Sales FROM Sales.Orders; 6. SQL Window Rules RULE 1 – Window functions can only be used in SELECT or ORDER BY SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER (PARTITION BY OrderStatus) AS Total_Sales FROM Sales.Orders WHERE SUM(Sales) OVER (PARTITION BY OrderStatus) &gt; 100; -- ❌ Invalid RULE 2 – Window functions cannot be nested SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(SUM(Sales) OVER (PARTITION BY OrderStatus)) OVER (PARTITION BY OrderStatus) AS Total_Sales -- ❌ Invalid nesting FROM Sales.Orders; 7. SQL Window with GROUP BY TASK 12 – Rank customers by total sales SELECT CustomerID, SUM(Sales) AS Total_Sales, RANK() OVER (ORDER BY SUM(Sales) DESC) AS Rank_Customers FROM Sales.Orders GROUP BY CustomerID;</description>
    </item>
    <item>
      <title>Window Aggregate Functions</title>
      <link>http://localhost:1313/sql/window_aggregations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/window_aggregations/</guid>
      <description>These functions allow you to perform aggregate calculations over a set of rows without the need for complex subqueries. They enable you to compute counts, sums, averages, minimums, and maximums while still retaining access to individual row details.&#xA;Table of Contents COUNT SUM AVG MAX / MIN ROLLING SUM &amp; AVERAGE Use Case COUNT Task 1: Find the Total Number of Orders and the Total Number of Orders for Each Customer SELECT OrderID, OrderDate, CustomerID, COUNT(*) OVER() AS TotalOrders, COUNT(*) OVER(PARTITION BY CustomerID) AS OrdersByCustomers FROM Sales.Orders Task 2: Find the Total Number of Customers, Scores, and Countries SELECT *, COUNT(*) OVER () AS TotalCustomersStar, COUNT(1) OVER () AS TotalCustomersOne, COUNT(Score) OVER() AS TotalScores, COUNT(Country) OVER() AS TotalCountries FROM Sales.Customers Task 3: Check whether the table ‘OrdersArchive’ contains any duplicate rows SELECT * FROM ( SELECT *, COUNT(*) OVER(PARTITION BY OrderID) AS CheckDuplicates FROM Sales.OrdersArchive ) t WHERE CheckDuplicates &gt; 1 SUM Task 4: Find the Total Sales Across All Orders and per Product SELECT OrderID, OrderDate, Sales, ProductID, SUM(Sales) OVER () AS TotalSales, SUM(Sales) OVER (PARTITION BY ProductID) AS SalesByProduct FROM Sales.Orders Task 5: Find the Percentage Contribution of Each Product’s Sales to the Total Sales SELECT OrderID, ProductID, Sales, SUM(Sales) OVER () AS TotalSales, ROUND(CAST(Sales AS FLOAT) / SUM(Sales) OVER () * 100, 2) AS PercentageOfTotal FROM Sales.Orders AVG Task 6: Find the Average Sales Across All Orders and per Product SELECT OrderID, OrderDate, Sales, ProductID, AVG(Sales) OVER () AS AvgSales, AVG(Sales) OVER (PARTITION BY ProductID) AS AvgSalesByProduct FROM Sales.Orders Task 7: Find the Average Scores of Customers SELECT CustomerID, LastName, Score, COALESCE(Score, 0) AS CustomerScore, AVG(Score) OVER () AS AvgScore, AVG(COALESCE(Score, 0)) OVER () AS AvgScoreWithoutNull FROM Sales.Customers Task 8: Find all orders where Sales exceed the average Sales across all orders SELECT * FROM ( SELECT OrderID, ProductID, Sales, AVG(Sales) OVER () AS Avg_Sales FROM Sales.Orders ) t WHERE Sales &gt; Avg_Sales MAX / MIN Task 9: Find the Highest and Lowest Sales across all orders SELECT MIN(Sales) AS MinSales, MAX(Sales) AS MaxSales FROM Sales.Orders Task 10: Find the Lowest Sales across all orders and by Product SELECT OrderID, ProductID, OrderDate, Sales, MIN(Sales) OVER () AS LowestSales, MIN(Sales) OVER (PARTITION BY ProductID) AS LowestSalesByProduct FROM Sales.Orders Task 11: Show the employees who have the highest salaries SELECT * FROM ( SELECT *, MAX(Salary) OVER() AS HighestSalary FROM Sales.Employees ) t WHERE Salary = HighestSalary Task 12: Find the deviation of each Sale from the minimum and maximum Sales SELECT OrderID, OrderDate, ProductID, Sales, MAX(Sales) OVER () AS HighestSales, MIN(Sales) OVER () AS LowestSales, Sales - MIN(Sales) OVER () AS DeviationFromMin, MAX(Sales) OVER () - Sales AS DeviationFromMax FROM Sales.Orders ROLLING SUM &amp; AVERAGE Use Case Task 13: Calculate the moving average of Sales for each Product over time SELECT OrderID, ProductID, OrderDate, Sales, AVG(Sales) OVER (PARTITION BY ProductID) AS AvgByProduct, AVG(Sales) OVER (PARTITION BY ProductID ORDER BY OrderDate) AS MovingAvg FROM Sales.Orders Task 14: Calculate the moving average of Sales for each Product over time, including only the next order SELECT OrderID, ProductID, OrderDate, Sales, AVG(Sales) OVER (PARTITION BY ProductID ORDER BY OrderDate ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS RollingAvg FROM Sales.Orders</description>
    </item>
    <item>
      <title>Window Ranking Functions</title>
      <link>http://localhost:1313/sql/window-ranking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/window-ranking/</guid>
      <description>These functions allow you to rank and order rows within a result set without the need for complex joins or subqueries. They enable you to assign unique or non-unique rankings, group rows into buckets, and analyze data distributions on ordered data.&#xA;SQL WINDOW RANKING | ROW_NUMBER, RANK, DENSE_RANK Task 1: Rank Orders Based on Sales from Highest to Lowest SELECT OrderID, ProductID, Sales, ROW_NUMBER() OVER (ORDER BY Sales DESC) AS SalesRank_Row, RANK() OVER (ORDER BY Sales DESC) AS SalesRank_Rank, DENSE_RANK() OVER (ORDER BY Sales DESC) AS SalesRank_Dense FROM Sales.Orders; Task 2: Top-N Analysis → Find the Highest Sale for Each Product SELECT * FROM ( SELECT OrderID, ProductID, Sales, ROW_NUMBER() OVER (PARTITION BY ProductID ORDER BY Sales DESC) AS RankByProduct FROM Sales.Orders ) AS TopProductSales WHERE RankByProduct = 1; Task 3: Bottom-N Analysis → Find the Lowest 2 Customers Based on Total Sales SELECT * FROM ( SELECT CustomerID, SUM(Sales) AS TotalSales, ROW_NUMBER() OVER (ORDER BY SUM(Sales)) AS RankCustomers FROM Sales.Orders GROUP BY CustomerID ) AS BottomCustomerSales WHERE RankCustomers &lt;= 2; Task 4: Assign Unique IDs to Rows of the ‘Order Archive’ SELECT ROW_NUMBER() OVER (ORDER BY OrderID, OrderDate) AS UniqueID, * FROM Sales.OrdersArchive; Task 5: Identify Duplicates in ‘Order Archive’ SELECT * FROM ( SELECT ROW_NUMBER() OVER (PARTITION BY OrderID ORDER BY CreationTime DESC) AS rn, * FROM Sales.OrdersArchive ) AS UniqueOrdersArchive WHERE rn = 1; SQL WINDOW RANKING | NTILE Task 6: Divide Orders into Groups Based on Sales SELECT OrderID, Sales, NTILE(1) OVER (ORDER BY Sales) AS OneBucket, NTILE(2) OVER (ORDER BY Sales) AS TwoBuckets, NTILE(3) OVER (ORDER BY Sales) AS ThreeBuckets, NTILE(4) OVER (ORDER BY Sales) AS FourBuckets, NTILE(2) OVER (PARTITION BY ProductID ORDER BY Sales) AS TwoBucketByProducts FROM Sales.Orders; Task 7: Segment Orders into High, Medium, and Low Sales SELECT OrderID, Sales, Buckets, CASE WHEN Buckets = 1 THEN &#39;High&#39; WHEN Buckets = 2 THEN &#39;Medium&#39; WHEN Buckets = 3 THEN &#39;Low&#39; END AS SalesSegmentations FROM ( SELECT OrderID, Sales, NTILE(3) OVER (ORDER BY Sales DESC) AS Buckets FROM Sales.Orders ) AS SalesBuckets; Task 8: Divide Orders into Groups for Processing SELECT NTILE(5) OVER (ORDER BY OrderID) AS Buckets, * FROM Sales.Orders; SQL WINDOW RANKING | CUME_DIST Task 9: Find Products Within the Highest 40% of Prices SELECT Product, Price, DistRank, CONCAT(DistRank * 100, &#39;%&#39;) AS DistRankPerc FROM ( SELECT Product, Price, CUME_DIST() OVER (ORDER BY Price DESC) AS DistRank FROM Sales.Products ) AS PriceDistribution WHERE DistRank &lt;= 0.4;</description>
    </item>
    <item>
      <title>Window Value Functions</title>
      <link>http://localhost:1313/sql/window-value-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/window-value-functions/</guid>
      <description>These functions let you reference and compare values from other rows in a result set without complex joins or subqueries, enabling advanced analysis on ordered data.&#xA;SQL WINDOW VALUE | LEAD, LAG Task 1: Analyze Month-over-Month Performance Find the percentage change in sales between the current and previous months.&#xA;SELECT *, CurrentMonthSales - PreviousMonthSales AS MoM_Change, ROUND( CAST((CurrentMonthSales - PreviousMonthSales) AS FLOAT) / PreviousMonthSales * 100, 1 ) AS MoM_Perc FROM ( SELECT MONTH(OrderDate) AS OrderMonth, SUM(Sales) AS CurrentMonthSales, LAG(SUM(Sales)) OVER (ORDER BY MONTH(OrderDate)) AS PreviousMonthSales FROM Sales.Orders GROUP BY MONTH(OrderDate) ) AS MonthlySales; Task 2: Customer Loyalty Analysis Rank customers based on the average days between their orders.</description>
    </item>
    <item>
      <title>Subquery Functions</title>
      <link>http://localhost:1313/sql/subqueries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/subqueries/</guid>
      <description>This script demonstrates various subquery techniques in SQL.&#xA;It covers result types, subqueries in the FROM clause, in SELECT, in JOIN clauses, with comparison operators, IN, ANY, correlated subqueries, and EXISTS.&#xA;Table of Contents SUBQUERY - RESULT TYPES SUBQUERY - FROM CLAUSE SUBQUERY - SELECT SUBQUERY - JOIN CLAUSE SUBQUERY - COMPARISON OPERATORS SUBQUERY - IN OPERATOR SUBQUERY - ANY OPERATOR SUBQUERY - CORRELATED SUBQUERY - EXISTS OPERATOR SUBQUERY | RESULT TYPES Scalar Query SELECT AVG(Sales) FROM Sales.Orders; Row Query SELECT CustomerID FROM Sales.Orders; Table Query SELECT OrderID, OrderDate FROM Sales.Orders; SUBQUERY | FROM CLAUSE Task 1: Products with Price Higher than Average Price SELECT * FROM ( SELECT ProductID, Price, AVG(Price) OVER () AS AvgPrice FROM Sales.Products ) AS t WHERE Price &gt; AvgPrice; Task 2: Rank Customers by Total Sales SELECT *, RANK() OVER (ORDER BY TotalSales DESC) AS CustomerRank FROM ( SELECT CustomerID, SUM(Sales) AS TotalSales FROM Sales.Orders GROUP BY CustomerID ) AS t; SUBQUERY | SELECT Task 3: Product Details with Total Number of Orders SELECT ProductID, Product, Price, (SELECT COUNT(*) FROM Sales.Orders) AS TotalOrders FROM Sales.Products; SUBQUERY | JOIN CLAUSE Task 4: Customer Details with Total Sales SELECT c.*, t.TotalSales FROM Sales.Customers AS c LEFT JOIN ( SELECT CustomerID, SUM(Sales) AS TotalSales FROM Sales.Orders GROUP BY CustomerID ) AS t ON c.CustomerID = t.CustomerID; Task 5: Customer Details with Total Orders SELECT c.*, o.TotalOrders FROM Sales.Customers AS c LEFT JOIN ( SELECT CustomerID, COUNT(*) AS TotalOrders FROM Sales.Orders GROUP BY CustomerID ) AS o ON c.CustomerID = o.CustomerID; SUBQUERY | COMPARISON OPERATORS Task 6: Products with Price Higher than Average Price SELECT ProductID, Price, (SELECT AVG(Price) FROM Sales.Products) AS AvgPrice FROM Sales.Products WHERE Price &gt; (SELECT AVG(Price) FROM Sales.Products); SUBQUERY | IN OPERATOR Task 7: Orders Made by Customers in Germany SELECT * FROM Sales.Orders WHERE CustomerID IN ( SELECT CustomerID FROM Sales.Customers WHERE Country = &#39;Germany&#39; ); Task 8: Orders Made by Customers Not in Germany SELECT * FROM Sales.Orders WHERE CustomerID NOT IN ( SELECT CustomerID FROM Sales.Customers WHERE Country = &#39;Germany&#39; ); SUBQUERY | ANY OPERATOR Task 9: Female Employees with Salaries Greater than Any Male Employee SELECT EmployeeID, FirstName, Salary FROM Sales.Employees WHERE Gender = &#39;F&#39; AND Salary &gt; ANY ( SELECT Salary FROM Sales.Employees WHERE Gender = &#39;M&#39; ); CORRELATED SUBQUERY Task 10: Customer Details with Total Orders (Correlated) SELECT *, (SELECT COUNT(*) FROM Sales.Orders o WHERE o.CustomerID = c.CustomerID) AS TotalSales FROM Sales.Customers AS c; SUBQUERY | EXISTS OPERATOR Task 11: Orders Made by Customers in Germany SELECT * FROM Sales.Orders AS o WHERE EXISTS ( SELECT 1 FROM Sales.Customers AS c WHERE Country = &#39;Germany&#39; AND o.CustomerID = c.CustomerID ); Task 12: Orders Made by Customers Not in Germany SELECT * FROM Sales.Orders AS o WHERE NOT EXISTS ( SELECT 1 FROM Sales.Customers AS c WHERE Country = &#39;Germany&#39; AND o.CustomerID = c.CustomerID );</description>
    </item>
    <item>
      <title>Common Table Expressions (CTEs)</title>
      <link>http://localhost:1313/sql/cte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/cte/</guid>
      <description>This script demonstrates the use of Common Table Expressions (CTEs) in SQL Server.&#xA;It includes examples of non-recursive CTEs for data aggregation and segmentation, as well as recursive CTEs for generating sequences and building hierarchical data.&#xA;NON-RECURSIVE CTE -- Step 1 → Total Sales Per Customer WITH CTE_Total_Sales AS ( SELECT CustomerID, SUM(Sales) AS TotalSales FROM Sales.Orders GROUP BY CustomerID ) -- Step 2 → Last Order Date for Each Customer , CTE_Last_Order AS ( SELECT CustomerID, MAX(OrderDate) AS Last_Order FROM Sales.Orders GROUP BY CustomerID ) -- Step 3 → Rank Customers by Total Sales , CTE_Customer_Rank AS ( SELECT CustomerID, TotalSales, RANK() OVER (ORDER BY TotalSales DESC) AS CustomerRank FROM CTE_Total_Sales ) -- Step 4 → Segment Customers by Sales , CTE_Customer_Segments AS ( SELECT CustomerID, TotalSales, CASE WHEN TotalSales &gt; 100 THEN &#39;High&#39; WHEN TotalSales &gt; 80 THEN &#39;Medium&#39; ELSE &#39;Low&#39; END AS CustomerSegments FROM CTE_Total_Sales ) -- Final Query Combining All CTEs SELECT c.CustomerID, c.FirstName, c.LastName, cts.TotalSales, clo.Last_Order, ccr.CustomerRank, ccs.CustomerSegments FROM Sales.Customers AS c LEFT JOIN CTE_Total_Sales AS cts ON cts.CustomerID = c.CustomerID LEFT JOIN CTE_Last_Order AS clo ON clo.CustomerID = c.CustomerID LEFT JOIN CTE_Customer_Rank AS ccr ON ccr.CustomerID = c.CustomerID LEFT JOIN CTE_Customer_Segments AS ccs ON ccs.CustomerID = c.CustomerID; RECURSIVE CTE | GENERATE SEQUENCE Task 2: Generate Numbers 1 to 20 WITH Series AS ( SELECT 1 AS MyNumber UNION ALL SELECT MyNumber + 1 FROM Series WHERE MyNumber &lt; 20 ) SELECT * FROM Series; Task 3: Generate Numbers 1 to 1000 WITH Series AS ( SELECT 1 AS MyNumber UNION ALL SELECT MyNumber + 1 FROM Series WHERE MyNumber &lt; 1000 ) SELECT * FROM Series OPTION (MAXRECURSION 5000); RECURSIVE CTE | BUILD HIERARCHY Task 4: Build Employee Hierarchy Display each employee’s level within the organization.</description>
    </item>
    <item>
      <title>Views</title>
      <link>http://localhost:1313/sql/views/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/views/</guid>
      <description>This script demonstrates various view use cases in SQL Server.&#xA;It includes examples for creating, dropping, and modifying views, hiding query complexity, and implementing data security by controlling data access.&#xA;CREATE, DROP, MODIFY VIEW Task: Create a Monthly Sales Summary View Aggregate by OrderMonth with total sales, total orders, and total quantities.&#xA;-- Create View CREATE VIEW Sales.V_Monthly_Summary AS ( SELECT DATETRUNC(month, OrderDate) AS OrderMonth, SUM(Sales) AS TotalSales, COUNT(OrderID) AS TotalOrders, SUM(Quantity) AS TotalQuantities FROM Sales.Orders GROUP BY DATETRUNC(month, OrderDate) ); GO -- Query the View SELECT * FROM Sales.V_Monthly_Summary; -- Drop View if it exists IF OBJECT_ID(&#39;Sales.V_Monthly_Summary&#39;, &#39;V&#39;) IS NOT NULL DROP VIEW Sales.V_Monthly_Summary; GO -- Re-create the View with modified logic CREATE VIEW Sales.V_Monthly_Summary AS SELECT DATETRUNC(month, OrderDate) AS OrderMonth, SUM(Sales) AS TotalSales, COUNT(OrderID) AS TotalOrders FROM Sales.Orders GROUP BY DATETRUNC(month, OrderDate); GO VIEW USE CASE | HIDE COMPLEXITY Task: Abstract Multi-Table Joins with a View Join Orders, Products, Customers, and Employees into a single view.</description>
    </item>
    <item>
      <title>Temporary Tables</title>
      <link>http://localhost:1313/sql/temporary-tables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/temporary-tables/</guid>
      <description>This script provides a generic example of data migration using a temporary table.&#xA;Step 1: Create Temporary Table (#Orders) SELECT * INTO #Orders FROM Sales.Orders; Step 2: Clean Data in Temporary Table DELETE FROM #Orders WHERE OrderStatus = &#39;Delivered&#39;; Step 3: Load Cleaned Data into Permanent Table SELECT * INTO Sales.OrdersTest FROM #Orders;</description>
    </item>
    <item>
      <title>Stored Procedures</title>
      <link>http://localhost:1313/sql/stored-procedures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/stored-procedures/</guid>
      <description>This script shows how to work with stored procedures in SQL Server, starting from basic implementations and advancing to more sophisticated techniques.&#xA;1. Basic Stored Procedure -- Define the Stored Procedure CREATE PROCEDURE GetCustomerSummary AS BEGIN SELECT COUNT(*) AS TotalCustomers, AVG(Score) AS AvgScore FROM Sales.Customers WHERE Country = &#39;USA&#39;; END GO -- Execute Stored Procedure EXEC GetCustomerSummary; 2. Parameters in Stored Procedure -- Edit the Stored Procedure ALTER PROCEDURE GetCustomerSummary @Country NVARCHAR(50) = &#39;USA&#39; AS BEGIN -- Reports: Summary from Customers and Orders SELECT COUNT(*) AS TotalCustomers, AVG(Score) AS AvgScore FROM Sales.Customers WHERE Country = @Country; END GO -- Execute Stored Procedure EXEC GetCustomerSummary @Country = &#39;Germany&#39;; EXEC GetCustomerSummary @Country = &#39;USA&#39;; EXEC GetCustomerSummary; 3. Multiple Queries in Stored Procedure -- Edit the Stored Procedure ALTER PROCEDURE GetCustomerSummary @Country NVARCHAR(50) = &#39;USA&#39; AS BEGIN -- Query 1: Find the Total Nr. of Customers and the Average Score SELECT COUNT(*) AS TotalCustomers, AVG(Score) AS AvgScore FROM Sales.Customers WHERE Country = @Country; -- Query 2: Find the Total Nr. of Orders and Total Sales SELECT COUNT(OrderID) AS TotalOrders, SUM(Sales) AS TotalSales FROM Sales.Orders AS o JOIN Sales.Customers AS c ON c.CustomerID = o.CustomerID WHERE c.Country = @Country; END GO -- Execute Stored Procedure EXEC GetCustomerSummary @Country = &#39;Germany&#39;; EXEC GetCustomerSummary @Country = &#39;USA&#39;; EXEC GetCustomerSummary; 4. Variables in Stored Procedure -- Edit the Stored Procedure ALTER PROCEDURE GetCustomerSummary @Country NVARCHAR(50) = &#39;USA&#39; AS BEGIN -- Declare Variables DECLARE @TotalCustomers INT, @AvgScore FLOAT; -- Query 1: Find the Total Nr. of Customers and the Average Score SELECT @TotalCustomers = COUNT(*), @AvgScore = AVG(Score) FROM Sales.Customers WHERE Country = @Country; PRINT(&#39;Total Customers from &#39; + @Country + &#39;:&#39; + CAST(@TotalCustomers AS NVARCHAR)); PRINT(&#39;Average Score from &#39; + @Country + &#39;:&#39; + CAST(@AvgScore AS NVARCHAR)); -- Query 2: Find the Total Nr. of Orders and Total Sales SELECT COUNT(OrderID) AS TotalOrders, SUM(Sales) AS TotalSales FROM Sales.Orders AS o JOIN Sales.Customers AS c ON c.CustomerID = o.CustomerID WHERE c.Country = @Country; END GO -- Execute Stored Procedure EXEC GetCustomerSummary @Country = &#39;Germany&#39;; EXEC GetCustomerSummary @Country = &#39;USA&#39;; EXEC GetCustomerSummary; 5. Control Flow with IF/ELSE ALTER PROCEDURE GetCustomerSummary @Country NVARCHAR(50) = &#39;USA&#39; AS BEGIN -- Declare Variables DECLARE @TotalCustomers INT, @AvgScore FLOAT; /* -------------------------------------------------------------------------- Prepare &amp; Cleanup Data -------------------------------------------------------------------------- */ IF EXISTS (SELECT 1 FROM Sales.Customers WHERE Score IS NULL AND Country = @Country) BEGIN PRINT(&#39;Updating NULL Scores to 0&#39;); UPDATE Sales.Customers SET Score = 0 WHERE Score IS NULL AND Country = @Country; END ELSE BEGIN PRINT(&#39;No NULL Scores found&#39;); END; /* -------------------------------------------------------------------------- Generating Reports -------------------------------------------------------------------------- */ SELECT @TotalCustomers = COUNT(*), @AvgScore = AVG(Score) FROM Sales.Customers WHERE Country = @Country; PRINT(&#39;Total Customers from &#39; + @Country + &#39;:&#39; + CAST(@TotalCustomers AS NVARCHAR)); PRINT(&#39;Average Score from &#39; + @Country + &#39;:&#39; + CAST(@AvgScore AS NVARCHAR)); SELECT COUNT(OrderID) AS TotalOrders, SUM(Sales) AS TotalSales, 1/0 AS FaultyCalculation -- Intentional error for demonstration FROM Sales.Orders AS o JOIN Sales.Customers AS c ON c.CustomerID = o.CustomerID WHERE c.Country = @Country; END GO -- Execute Stored Procedure EXEC GetCustomerSummary @Country = &#39;Germany&#39;; EXEC GetCustomerSummary @Country = &#39;USA&#39;; EXEC GetCustomerSummary; 6. Error Handling with TRY/CATCH ALTER PROCEDURE GetCustomerSummary @Country NVARCHAR(50) = &#39;USA&#39; AS BEGIN BEGIN TRY -- Declare Variables DECLARE @TotalCustomers INT, @AvgScore FLOAT; /* -------------------------------------------------------------------------- Prepare &amp; Cleanup Data -------------------------------------------------------------------------- */ IF EXISTS (SELECT 1 FROM Sales.Customers WHERE Score IS NULL AND Country = @Country) BEGIN PRINT(&#39;Updating NULL Scores to 0&#39;); UPDATE Sales.Customers SET Score = 0 WHERE Score IS NULL AND Country = @Country; END ELSE BEGIN PRINT(&#39;No NULL Scores found&#39;); END; /* -------------------------------------------------------------------------- Generating Reports -------------------------------------------------------------------------- */ SELECT @TotalCustomers = COUNT(*), @AvgScore = AVG(Score) FROM Sales.Customers WHERE Country = @Country; PRINT(&#39;Total Customers from &#39; + @Country + &#39;:&#39; + CAST(@TotalCustomers AS NVARCHAR)); PRINT(&#39;Average Score from &#39; + @Country + &#39;:&#39; + CAST(@AvgScore AS NVARCHAR)); SELECT COUNT(OrderID) AS TotalOrders, SUM(Sales) AS TotalSales, 1/0 AS FaultyCalculation -- Intentional error for demonstration FROM Sales.Orders AS o JOIN Sales.Customers AS c ON c.CustomerID = o.CustomerID WHERE c.Country = @Country; END TRY BEGIN CATCH /* -------------------------------------------------------------------------- Error Handling -------------------------------------------------------------------------- */ PRINT(&#39;An error occurred.&#39;); PRINT(&#39;Error Message: &#39; + ERROR_MESSAGE()); PRINT(&#39;Error Number: &#39; + CAST(ERROR_NUMBER() AS NVARCHAR)); PRINT(&#39;Error Severity: &#39; + CAST(ERROR_SEVERITY() AS NVARCHAR)); PRINT(&#39;Error State: &#39; + CAST(ERROR_STATE() AS NVARCHAR)); PRINT(&#39;Error Line: &#39; + CAST(ERROR_LINE() AS NVARCHAR)); PRINT(&#39;Error Procedure: &#39; + ISNULL(ERROR_PROCEDURE(), &#39;N/A&#39;)); END CATCH; END GO -- Execute Stored Procedure EXEC GetCustomerSummary @Country = &#39;Germany&#39;; EXEC GetCustomerSummary @Country = &#39;USA&#39;; EXEC GetCustomerSummary;</description>
    </item>
    <item>
      <title>Triggers</title>
      <link>http://localhost:1313/sql/triggers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/triggers/</guid>
      <description>This script demonstrates:&#xA;The creation of a logging table. A trigger on the Sales.Employees table. An insert operation that fires the trigger. The trigger logs details of newly added employees into the Sales.EmployeeLogs table.&#xA;Step 1: Create Log Table CREATE TABLE Sales.EmployeeLogs ( LogID INT IDENTITY(1,1) PRIMARY KEY, EmployeeID INT, LogMessage VARCHAR(255), LogDate DATE ); GO Step 2: Create Trigger on Employees Table CREATE TRIGGER trg_AfterInsertEmployee ON Sales.Employees AFTER INSERT AS BEGIN INSERT INTO Sales.EmployeeLogs (EmployeeID, LogMessage, LogDate) SELECT EmployeeID, &#39;New Employee Added = &#39; + CAST(EmployeeID AS VARCHAR), GETDATE() FROM INSERTED; END; GO Step 3: Insert New Data Into Employees INSERT INTO Sales.Employees VALUES (6, &#39;Maria&#39;, &#39;Doe&#39;, &#39;HR&#39;, &#39;1988-01-12&#39;, &#39;F&#39;, 80000, 3); GO Step 4: Check the Logs SELECT * FROM Sales.EmployeeLogs; GO</description>
    </item>
    <item>
      <title>Indexes</title>
      <link>http://localhost:1313/sql/indexes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/indexes/</guid>
      <description>This script demonstrates various index types in SQL Server including clustered, non-clustered, columnstore, unique, and filtered indexes.&#xA;It also covers index monitoring techniques like usage stats, missing/duplicate indexes, updating statistics, and fragmentation.&#xA;📑 Table of Contents Index Types Clustered and Non-Clustered Indexes Leftmost Prefix Rule Explanation Columnstore Indexes Unique Indexes Filtered Indexes Index Monitoring Monitor Index Usage Monitor Missing Indexes Monitor Duplicate Indexes Update Statistics Fragmentations Index Types Clustered and Non-Clustered Indexes -- Create a Heap Table as a copy of Sales.Customers SELECT * INTO Sales.DBCustomers FROM Sales.Customers; -- Test Query SELECT * FROM Sales.DBCustomers WHERE CustomerID = 1; -- Create a Clustered Index CREATE CLUSTERED INDEX idx_DBCustomers_CustomerID ON Sales.DBCustomers (CustomerID); -- Attempt to create a second Clustered Index (will fail) CREATE CLUSTERED INDEX idx_DBCustomers_CustomerID ON Sales.DBCustomers (CustomerID); -- Drop the Clustered Index DROP INDEX idx_DBCustomers_CustomerID ON Sales.DBCustomers; -- Query using LastName filter SELECT * FROM Sales.DBCustomers WHERE LastName = &#39;Brown&#39;; -- Create a Non-Clustered Index on LastName CREATE NONCLUSTERED INDEX idx_DBCustomers_LastName ON Sales.DBCustomers (LastName); -- Additional Non-Clustered Index on FirstName CREATE INDEX idx_DBCustomers_FirstName ON Sales.DBCustomers (FirstName); -- Composite Index on Country and Score CREATE INDEX idx_DBCustomers_CountryScore ON Sales.DBCustomers (Country, Score); -- Query that uses Composite Index SELECT * FROM Sales.DBCustomers WHERE Country = &#39;USA&#39; AND Score &gt; 500; -- Query that may not use Composite Index due to column order SELECT * FROM Sales.DBCustomers WHERE Score &gt; 500 AND Country = &#39;USA&#39;; Leftmost Prefix Rule Explanation For a composite index (A, B, C, D) the index is useful when filtering on:</description>
    </item>
    <item>
      <title>Partitioning</title>
      <link>http://localhost:1313/sql/partitions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/partitions/</guid>
      <description>This script demonstrates SQL Server partitioning features including:&#xA;Partition functions, filegroups, data files, partition schemes Partitioned tables and data insertion Verification queries and execution plan comparisons Step 1: Create a Partition Function -- Create Left Range Partition Functions based on Years CREATE PARTITION FUNCTION PartitionByYear (DATE) AS RANGE LEFT FOR VALUES (&#39;2023-12-31&#39;, &#39;2024-12-31&#39;, &#39;2025-12-31&#39;); -- List all existing Partition Functions SELECT name, function_id, type, type_desc, boundary_value_on_right FROM sys.partition_functions; Step 2: Create Filegroups -- Create Filegroups in SalesDB ALTER DATABASE SalesDB ADD FILEGROUP FG_2023; ALTER DATABASE SalesDB ADD FILEGROUP FG_2024; ALTER DATABASE SalesDB ADD FILEGROUP FG_2025; ALTER DATABASE SalesDB ADD FILEGROUP FG_2026; -- Optional: Remove a Filegroup ALTER DATABASE SalesDB REMOVE FILEGROUP FG_2023; -- List existing Filegroups SELECT * FROM sys.filegroups WHERE type = &#39;FG&#39;; Step 3: Create Data Files -- Create Data Files and map them to Filegroups ALTER DATABASE SalesDB ADD FILE ( NAME = P_2023, FILENAME = &#39;C:\Program Files\Microsoft SQL Server\MSSQL16.SQLEXPRESS\MSSQL\DATA\P_2023.ndf&#39; ) TO FILEGROUP FG_2023; ALTER DATABASE SalesDB ADD FILE ( NAME = P_2024, FILENAME = &#39;C:\Program Files\Microsoft SQL Server\MSSQL16.SQLEXPRESS\MSSQL\DATA\P_2024.ndf&#39; ) TO FILEGROUP FG_2024; ALTER DATABASE SalesDB ADD FILE ( NAME = P_2025, FILENAME = &#39;C:\Program Files\Microsoft SQL Server\MSSQL16.SQLEXPRESS\MSSQL\DATA\P_2025.ndf&#39; ) TO FILEGROUP FG_2025; ALTER DATABASE SalesDB ADD FILE ( NAME = P_2026, FILENAME = &#39;C:\Program Files\Microsoft SQL Server\MSSQL16.SQLEXPRESS\MSSQL\DATA\P_2026.ndf&#39; ) TO FILEGROUP FG_2026; -- List all files in SalesDB SELECT fg.name AS FilegroupName, mf.name AS LogicalFileName, mf.physical_name AS PhysicalFilePath, mf.size / 128 AS SizeInMB FROM sys.filegroups fg JOIN sys.master_files mf ON fg.data_space_id = mf.data_space_id WHERE mf.database_id = DB_ID(&#39;SalesDB&#39;); Step 4: Create Partition Scheme -- Partition Scheme using the Partition Function CREATE PARTITION SCHEME SchemePartitionByYear AS PARTITION PartitionByYear TO (FG_2023, FG_2024, FG_2025, FG_2026); -- List Partition Schemes SELECT ps.name AS PartitionSchemeName, pf.name AS PartitionFunctionName, ds.destination_id AS PartitionNumber, fg.name AS FilegroupName FROM sys.partition_schemes ps JOIN sys.partition_functions pf ON ps.function_id = pf.function_id JOIN sys.destination_data_spaces ds ON ps.data_space_id = ds.partition_scheme_id JOIN sys.filegroups fg ON ds.data_space_id = fg.data_space_id; Step 5: Create the Partitioned Table CREATE TABLE Sales.Orders_Partitioned ( OrderID INT, OrderDate DATE, Sales INT ) ON SchemePartitionByYear (OrderDate); Step 6: Insert Data Into the Partitioned Table INSERT INTO Sales.Orders_Partitioned VALUES (1, &#39;2023-05-15&#39;, 100); INSERT INTO Sales.Orders_Partitioned VALUES (2, &#39;2024-07-20&#39;, 50); INSERT INTO Sales.Orders_Partitioned VALUES (3, &#39;2025-12-31&#39;, 20); INSERT INTO Sales.Orders_Partitioned VALUES (4, &#39;2026-01-01&#39;, 100); Step 7: Verify Partitioning and Compare Execution Plans -- Verify that data is correctly partitioned SELECT p.partition_number AS PartitionNumber, f.name AS PartitionFilegroup, p.rows AS NumberOfRows FROM sys.partitions p JOIN sys.destination_data_spaces dds ON p.partition_number = dds.destination_id JOIN sys.filegroups f ON dds.data_space_id = f.data_space_id WHERE OBJECT_NAME(p.object_id) = &#39;Orders_Partitioned&#39;; -- Non-partitioned copy for comparison SELECT * INTO Sales.Orders_NoPartition FROM Sales.Orders_Partitioned; -- Query on Partitioned Table SELECT * FROM Sales.Orders_Partitioned WHERE OrderDate IN (&#39;2026-01-01&#39;, &#39;2025-12-31&#39;); -- Query on Non-Partitioned Table SELECT * FROM Sales.Orders_NoPartition WHERE OrderDate IN (&#39;2026-01-01&#39;, &#39;2025-12-31&#39;);</description>
    </item>
    <item>
      <title>Performance Tips</title>
      <link>http://localhost:1313/sql/performance-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/performance-optimization/</guid>
      <description>This guide demonstrates best practices for:&#xA;Fetching data Filtering Joins UNION Aggregations Subqueries/CTE DDL Indexing It covers techniques such as selecting only necessary columns, proper filtering methods, explicit joins, avoiding redundant logic, and efficient indexing strategies.&#xA;Fetching Data Tip 1: Select Only What You Need -- Bad Practice SELECT * FROM Sales.Customers; -- Good Practice SELECT CustomerID, FirstName, LastName FROM Sales.Customers; Tip 2: Avoid unnecessary DISTINCT &amp; ORDER BY -- Bad Practice SELECT DISTINCT FirstName FROM Sales.Customers ORDER BY FirstName; -- Good Practice SELECT FirstName FROM Sales.Customers; Tip 3: For Exploration Purpose, Limit Rows! -- Bad Practice SELECT OrderID, Sales FROM Sales.Orders; -- Good Practice SELECT TOP 10 OrderID, Sales FROM Sales.Orders; Filtering Tip 4: Create nonclustered index on frequently used columns SELECT * FROM Sales.Orders WHERE OrderStatus = &#39;Delivered&#39;; CREATE NONCLUSTERED INDEX Idx_Orders_OrderStatus ON Sales.Orders(OrderStatus); Tip 5: Avoid applying functions in WHERE -- Bad SELECT * FROM Sales.Orders WHERE LOWER(OrderStatus) = &#39;delivered&#39;; -- Good SELECT * FROM Sales.Orders WHERE OrderStatus = &#39;Delivered&#39;; -- Bad SELECT * FROM Sales.Customers WHERE SUBSTRING(FirstName, 1, 1) = &#39;A&#39;; -- Good SELECT * FROM Sales.Customers WHERE FirstName LIKE &#39;A%&#39;; -- Bad SELECT * FROM Sales.Orders WHERE YEAR(OrderDate) = 2025; -- Good SELECT * FROM Sales.Orders WHERE OrderDate BETWEEN &#39;2025-01-01&#39; AND &#39;2025-12-31&#39;; Tip 6: Avoid leading wildcards -- Bad SELECT * FROM Sales.Customers WHERE LastName LIKE &#39;%Gold%&#39;; -- Good SELECT * FROM Sales.Customers WHERE LastName LIKE &#39;Gold%&#39;; Tip 7: Use IN instead of multiple OR -- Bad SELECT * FROM Sales.Orders WHERE CustomerID = 1 OR CustomerID = 2 OR CustomerID = 3; -- Good SELECT * FROM Sales.Orders WHERE CustomerID IN (1, 2, 3); Joins Tip 8: Use INNER JOIN when possible -- Best SELECT c.FirstName, o.OrderID FROM Sales.Customers c INNER JOIN Sales.Orders o ON c.CustomerID = o.CustomerID; -- Slower SELECT c.FirstName, o.OrderID FROM Sales.Customers c LEFT JOIN Sales.Orders o ON c.CustomerID = o.CustomerID; -- Worst SELECT c.FirstName, o.OrderID FROM Sales.Customers c OUTER JOIN Sales.Orders o ON c.CustomerID = o.CustomerID; Tip 9: Use explicit (ANSI) joins -- Bad SELECT o.OrderID, c.FirstName FROM Sales.Customers c, Sales.Orders o WHERE c.CustomerID = o.CustomerID; -- Good SELECT o.OrderID, c.FirstName FROM Sales.Customers c INNER JOIN Sales.Orders o ON c.CustomerID = o.CustomerID; Tip 10: Index columns used in ON clause SELECT c.FirstName, o.OrderID FROM Sales.Orders o INNER JOIN Sales.Customers c ON c.CustomerID = o.CustomerID; CREATE NONCLUSTERED INDEX IX_Orders_CustomerID ON Sales.Orders(CustomerID); Tip 11: Filter before joining big tables -- Best for big tables SELECT c.FirstName, o.OrderID FROM Sales.Customers c INNER JOIN ( SELECT OrderID, CustomerID FROM Sales.Orders WHERE OrderStatus = &#39;Delivered&#39; ) o ON c.CustomerID = o.CustomerID; Tip 12: Aggregate before joining -- Best for big tables SELECT c.CustomerID, c.FirstName, o.OrderCount FROM Sales.Customers c INNER JOIN ( SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM Sales.Orders GROUP BY CustomerID ) o ON c.CustomerID = o.CustomerID; Tip 13: Use UNION instead of OR in joins -- Bad SELECT o.OrderID, c.FirstName FROM Sales.Customers c INNER JOIN Sales.Orders o ON c.CustomerID = o.CustomerID OR c.CustomerID = o.SalesPersonID; -- Good SELECT o.OrderID, c.FirstName FROM Sales.Customers c INNER JOIN Sales.Orders o ON c.CustomerID = o.CustomerID UNION SELECT o.OrderID, c.FirstName FROM Sales.Customers c INNER JOIN Sales.Orders o ON c.CustomerID = o.SalesPersonID; Tip 14: Use SQL hints for optimization SELECT o.OrderID, c.FirstName FROM Sales.Customers c INNER JOIN Sales.Orders o ON c.CustomerID = o.CustomerID OPTION (HASH JOIN); Union Tip 15: Use UNION ALL when duplicates are acceptable -- Bad SELECT CustomerID FROM Sales.Orders UNION SELECT CustomerID FROM Sales.OrdersArchive; -- Good SELECT CustomerID FROM Sales.Orders UNION ALL SELECT CustomerID FROM Sales.OrdersArchive; Tip 16: Use UNION ALL + DISTINCT when duplicates not allowed SELECT DISTINCT CustomerID FROM ( SELECT CustomerID FROM Sales.Orders UNION ALL SELECT CustomerID FROM Sales.OrdersArchive ) CombinedData; Aggregations Tip 17: Use columnstore indexes SELECT CustomerID, COUNT(OrderID) AS OrderCount FROM Sales.Orders GROUP BY CustomerID; CREATE CLUSTERED COLUMNSTORE INDEX Idx_Orders_Columnstore ON Sales.Orders; Tip 18: Pre-aggregate data SELECT MONTH(OrderDate) AS OrderYear, SUM(Sales) AS TotalSales INTO Sales.SalesSummary FROM Sales.Orders GROUP BY MONTH(OrderDate); SELECT OrderYear, TotalSales FROM Sales.SalesSummary; Subqueries &amp; CTE Tip 19: Prefer JOIN or EXISTS over IN -- Good SELECT o.OrderID, o.Sales FROM Sales.Orders o WHERE EXISTS ( SELECT 1 FROM Sales.Customers c WHERE c.CustomerID = o.CustomerID AND c.Country = &#39;USA&#39; ); -- Bad SELECT o.OrderID, o.Sales FROM Sales.Orders o WHERE o.CustomerID IN ( SELECT CustomerID FROM Sales.Customers WHERE Country = &#39;USA&#39; ); Tip 20: Avoid redundant logic -- Good SELECT EmployeeID, FirstName, CASE WHEN Salary &gt; AVG(Salary) OVER () THEN &#39;Above Average&#39; WHEN Salary &lt; AVG(Salary) OVER () THEN &#39;Below Average&#39; ELSE &#39;Average&#39; END AS Status FROM Sales.Employees; DDL Tip 21: Avoid VARCHAR(MAX) unless necessary. Tip 22: Avoid overly large lengths. Tip 23: Use NOT NULL when possible. Tip 24: All tables should have a clustered primary key. Tip 25: Create nonclustered indexes on foreign keys when frequently used. -- Good Practice CREATE TABLE CustomersInfo ( CustomerID INT PRIMARY KEY CLUSTERED, FirstName VARCHAR(50) NOT NULL, LastName VARCHAR(50) NOT NULL, Country VARCHAR(50) NOT NULL, TotalPurchases FLOAT, Score INT, BirthDate DATE, EmployeeID INT, CONSTRAINT FK_CustomersInfo_EmployeeID FOREIGN KEY (EmployeeID) REFERENCES Sales.Employees(EmployeeID) ); CREATE NONCLUSTERED INDEX IX_CustomersInfo_EmployeeID ON CustomersInfo(EmployeeID); Indexing Tip 26: Avoid over-indexing (slows down writes). Tip 27: Drop unused indexes regularly. Tip 28: Update table statistics weekly. Tip 29: Reorganize/rebuild fragmented indexes weekly. Tip 30: For very large tables, partition + columnstore index.</description>
    </item>
    <item>
      <title>AI and SQL</title>
      <link>http://localhost:1313/sql/ai-and-sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/sql/ai-and-sql/</guid>
      <description>This document contains a series of AI-powered prompts designed to help SQL developers and learners improve skills in writing, optimizing, and understanding SQL queries.&#xA;The prompts cover tasks, readability, performance, debugging, interview/exam prep, and more.&#xA;Each section provides clear instructions and sample code to support self-learning and real-world application.&#xA;Table of Contents Solve an SQL Task Improve the Readability Optimize the Performance Query Optimize Execution Plan Debugging Explain the Result Styling &amp; Formatting Documentations &amp; Comments Improve Database DDL Generate Test Dataset Create SQL Course Understand SQL Concept Comparing SQL Concepts SQL Questions with Options Prepare for a SQL Interview Prepare for a SQL Exam 1. Solve an SQL Task Prompt:&#xA;In my SQL Server database, we have two tables:</description>
    </item>
  </channel>
</rss>