<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SQL :: Data Engineering Notes</title>
    <link>https://example.org/sql/</link>
    <description>Course Content 1. Introduction What is SQL? Types of Databases (Relational vs Non-Relational) SQL vs NoSQL SQL Standards (ANSI SQL, T-SQL, PL/SQL, MySQL SQL, PostgreSQL SQL) 2. SQL Basics Database, Schema, Table Data Types (Numeric, String, Date/Time, Boolean, JSON, XML) CREATE, DROP, ALTER INSERT, UPDATE, DELETE SELECT Statement WHERE Clause ORDER BY LIMIT / TOP / FETCH 3. Filtering &amp; Operators Comparison Operators Logical Operators (AND, OR, NOT) BETWEEN, IN, LIKE IS NULL / IS NOT NULL Pattern Matching (Wildcards, Regex) 4. Functions String Functions (CONCAT, SUBSTRING, TRIM, UPPER, LOWER, LENGTH) Numeric Functions (ROUND, CEIL, FLOOR, ABS, MOD) Date/Time Functions (NOW, DATEADD, DATEDIFF, FORMAT) Conversion Functions (CAST, CONVERT) Aggregate Functions (COUNT, SUM, AVG, MIN, MAX) 5. Joins INNER JOIN LEFT JOIN RIGHT JOIN FULL OUTER JOIN CROSS JOIN SELF JOIN USING vs ON 6. Subqueries &amp; Nested Queries Scalar Subqueries Table Subqueries Correlated Subqueries EXISTS / NOT EXISTS IN / ANY / ALL 7. Set Operations UNION vs UNION ALL INTERSECT EXCEPT / MINUS 8. Grouping &amp; Aggregation GROUP BY HAVING GROUPING SETS ROLLUP CUBE 9. Constraints &amp; Keys Primary Key Foreign Key Unique Key Check Constraint Default Constraint Not Null 10. Indexing &amp; Performance Clustered vs Non-Clustered Index Composite Index Covering Index Index Maintenance Query Execution Plans SQL Performance Tuning 11. Transactions BEGIN, COMMIT, ROLLBACK Savepoints ACID Properties Isolation Levels (Read Uncommitted, Read Committed, Repeatable Read, Serializable, Snapshot) Deadlocks &amp; Locking 12. Views &amp; Materialized Views Creating Views Updatable Views Indexed Views Materialized Views Refresh Strategies 13. Stored Procedures &amp; Functions User-Defined Functions (Scalar, Table-Valued) Stored Procedures Parameters (IN, OUT, INOUT) Error Handling in Procedures Recursive Procedures Dynamic SQL 14. Triggers AFTER Trigger INSTEAD OF Trigger Row-level vs Statement-level Triggers Use Cases 15. Advanced SQL Window Functions (ROW_NUMBER, RANK, DENSE_RANK, NTILE) LAG &amp; LEAD FIRST_VALUE &amp; LAST_VALUE Common Table Expressions (CTEs) Recursive CTEs Pivoting and Unpivoting JSON &amp; XML in SQL Hierarchical Queries Full-Text Search 16. Security Users &amp; Roles GRANT, REVOKE, DENY Row-Level Security Column-Level Security Data Masking Encryption at Rest &amp; In-Transit 17. Advanced Database Concepts Normalization &amp; Denormalization Star &amp; Snowflake Schema Partitioning (Horizontal, Vertical) Sharding Federation Replication High Availability &amp; Failover 18. SQL with Big Data SQL on Hadoop / Hive Spark SQL SQL in Cloud Platforms (AWS Athena, BigQuery, Azure Synapse) 19. SQL in Practice Data Warehousing with SQL ETL using SQL Reporting Queries Performance Benchmarking Debugging Complex Queries 20. Capstone Project Design &amp; Implement Normalized Database Build ETL Pipeline using SQL Create Analytical Queries &amp; Reports Optimize Large-Scale SQL Workloads</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://example.org/sql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SELECT Query</title>
      <link>https://example.org/sql/select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/select/</guid>
      <description>This guide covers various SELECT query techniques used for retrieving, filtering, sorting, and aggregating data efficiently.&#xA;Comments -- This is a single-line comment. /* This is a multiple-line comment */ 1. SELECT ALL COLUMNS -- Retrieve All Customer Data SELECT * FROM customers; -- Retrieve All Order Data SELECT * FROM orders; 2. SELECT SPECIFIC COLUMNS -- Retrieve each customer&#39;s name, country, and score SELECT first_name, country, score FROM customers; 3. WHERE CLAUSE -- Retrieve customers with a score not equal to 0 SELECT * FROM customers WHERE score != 0; -- Retrieve customers from Germany SELECT * FROM customers WHERE country = &#39;Germany&#39;; -- Retrieve the name and country of customers from Germany SELECT first_name, country FROM customers WHERE country = &#39;Germany&#39;; 4. ORDER BY -- Sort by highest score first SELECT * FROM customers ORDER BY score DESC; -- Sort by lowest score first SELECT * FROM customers ORDER BY score ASC; -- Sort by country SELECT * FROM customers ORDER BY country ASC; -- Sort by country, then highest score SELECT * FROM customers ORDER BY country ASC, score DESC; -- Customers with score != 0, sorted by highest score SELECT first_name, country, score FROM customers WHERE score != 0 ORDER BY score DESC; 5. GROUP BY -- Find total score for each country SELECT country, SUM(score) AS total_score FROM customers GROUP BY country; -- ❌ Invalid: first_name not grouped or aggregated SELECT country, first_name, SUM(score) AS total_score FROM customers GROUP BY country; -- Find total score &amp; number of customers per country SELECT country, SUM(score) AS total_score, COUNT(id) AS total_customers FROM customers GROUP BY country; 6. HAVING -- Average score &gt; 430 for each country SELECT country, AVG(score) AS avg_score FROM customers GROUP BY country HAVING AVG(score) &gt; 430; -- Only consider customers with score != 0 SELECT country, AVG(score) AS avg_score FROM customers WHERE score != 0 GROUP BY country HAVING AVG(score) &gt; 430; 7. DISTINCT -- Unique list of countries SELECT DISTINCT country FROM customers; 8. TOP -- Retrieve only 3 customers SELECT TOP 3 * FROM customers; -- Top 3 customers with highest scores SELECT TOP 3 * FROM customers ORDER BY score DESC; -- Lowest 2 customers by score SELECT TOP 2 * FROM customers ORDER BY score ASC; -- Two most recent orders SELECT TOP 2 * FROM orders ORDER BY order_date DESC; 9. All Together -- Average score per country, excluding score=0, -- only &gt; 430, ordered by highest avg_score SELECT country, AVG(score) AS avg_score FROM customers WHERE score != 0 GROUP BY country HAVING AVG(score) &gt; 430 ORDER BY AVG(score) DESC; 10. COOL STUFF – Additional SQL Features -- Execute multiple queries at once SELECT * FROM customers; SELECT * FROM orders; -- Select static values SELECT 123 AS static_number; SELECT &#39;Hello&#39; AS static_string; -- Assign a constant value in query results SELECT id, first_name, &#39;New Customer&#39; AS customer_type FROM customers;</description>
    </item>
    <item>
      <title>DDL</title>
      <link>https://example.org/sql/ddl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/ddl/</guid>
      <description>This guide covers the essential DDL (Data Definition Language) commands used for defining and managing database structures, including creating, modifying, and deleting tables.&#xA;1. CREATE – Creating Tables -- Create a new table called persons -- with columns: id, person_name, birth_date, and phone CREATE TABLE persons ( id INT NOT NULL, person_name VARCHAR(50) NOT NULL, birth_date DATE, phone VARCHAR(15) NOT NULL, CONSTRAINT pk_persons PRIMARY KEY (id) ); 2. ALTER – Modifying Table Structure -- Add a new column called email to the persons table ALTER TABLE persons ADD email VARCHAR(50) NOT NULL; -- Remove the column phone from the persons table ALTER TABLE persons DROP COLUMN phone; 3. DROP – Removing Tables -- Delete the table persons from the database DROP TABLE persons;</description>
    </item>
    <item>
      <title>DML</title>
      <link>https://example.org/sql/dml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/dml/</guid>
      <description>This guide covers the essential DML (Data Manipulation Language) commands used for inserting, updating, and deleting data in database tables.&#xA;1. INSERT – Adding Data to Tables Method 1: Manual INSERT using VALUES -- Insert new records into the customers table INSERT INTO customers (id, first_name, country, score) VALUES (6, &#39;Anna&#39;, &#39;USA&#39;, NULL), (7, &#39;Sam&#39;, NULL, 100); -- Incorrect column order INSERT INTO customers (id, first_name, country, score) VALUES (8, &#39;Max&#39;, &#39;USA&#39;, NULL); -- Incorrect data type in values INSERT INTO customers (id, first_name, country, score) VALUES (&#39;Max&#39;, 9, &#39;Max&#39;, NULL); -- Insert a new record with full column values INSERT INTO customers (id, first_name, country, score) VALUES (8, &#39;Max&#39;, &#39;USA&#39;, 368); -- Insert without specifying column names (not recommended) INSERT INTO customers VALUES (9, &#39;Andreas&#39;, &#39;Germany&#39;, NULL); -- Insert a record with only id and first_name INSERT INTO customers (id, first_name) VALUES (10, &#39;Sahra&#39;); Method 2: INSERT using SELECT (Copying Data) -- Copy data from customers table into persons INSERT INTO persons (id, person_name, birth_date, phone) SELECT id, first_name, NULL, &#39;Unknown&#39; FROM customers; 2. UPDATE – Modifying Existing Data -- Change the score of customer with ID 6 to 0 UPDATE customers SET score = 0 WHERE id = 6; -- Change score and country for customer with ID 10 UPDATE customers SET score = 0, country = &#39;UK&#39; WHERE id = 10; -- Update all NULL scores to 0 UPDATE customers SET score = 0 WHERE score IS NULL; -- Verify the update SELECT * FROM customers WHERE score IS NULL; 3. DELETE – Removing Data from Tables -- Select customers with ID greater than 5 SELECT * FROM customers WHERE id &gt; 5; -- Delete customers with ID greater than 5 DELETE FROM customers WHERE id &gt; 5; -- Delete all rows from persons DELETE FROM persons; -- Faster method to delete all rows TRUNCATE TABLE persons;</description>
    </item>
    <item>
      <title>Filtering Data</title>
      <link>https://example.org/sql/filter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/filter/</guid>
      <description>This document provides an overview of SQL filtering techniques using WHERE and various operators for precise data retrieval.&#xA;1. Comparison Operators (=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=) -- Retrieve all customers from Germany SELECT * FROM customers WHERE country = &#39;Germany&#39;; -- Retrieve all customers who are not from Germany SELECT * FROM customers WHERE country &lt;&gt; &#39;Germany&#39;; -- Retrieve all customers with a score greater than 500 SELECT * FROM customers WHERE score &gt; 500; -- Retrieve all customers with a score of 500 or more SELECT * FROM customers WHERE score &gt;= 500; -- Retrieve all customers with a score less than 500 SELECT * FROM customers WHERE score &lt; 500; -- Retrieve all customers with a score of 500 or less SELECT * FROM customers WHERE score &lt;= 500; 2. Logical Operators (AND, OR, NOT) -- Customers from the USA and score &gt; 500 SELECT * FROM customers WHERE country = &#39;USA&#39; AND score &gt; 500; -- Customers from the USA or score &gt; 500 SELECT * FROM customers WHERE country = &#39;USA&#39; OR score &gt; 500; -- Customers with score not less than 500 SELECT * FROM customers WHERE NOT score &lt; 500; 3. Range Filtering – BETWEEN -- Customers with score between 100 and 500 SELECT * FROM customers WHERE score BETWEEN 100 AND 500; -- Equivalent to BETWEEN SELECT * FROM customers WHERE score &gt;= 100 AND score &lt;= 500; 4. Set Filtering – IN -- Customers from Germany or USA SELECT * FROM customers WHERE country IN (&#39;Germany&#39;, &#39;USA&#39;); 5. Pattern Matching – LIKE -- First name starts with &#39;M&#39; SELECT * FROM customers WHERE first_name LIKE &#39;M%&#39;; -- First name ends with &#39;n&#39; SELECT * FROM customers WHERE first_name LIKE &#39;%n&#39;; -- First name contains &#39;r&#39; SELECT * FROM customers WHERE first_name LIKE &#39;%r%&#39;; -- First name has &#39;r&#39; in the third position SELECT * FROM customers WHERE first_name LIKE &#39;__r%&#39;;</description>
    </item>
    <item>
      <title>Joins</title>
      <link>https://example.org/sql/joins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/joins/</guid>
      <description>This document provides an overview of SQL Joins, which allow combining data from multiple tables to retrieve meaningful insights.&#xA;1. Basic Joins No Join -- Retrieve all data from customers and orders as separate results SELECT * FROM customers; SELECT * FROM orders; INNER JOIN -- Get all customers along with their orders (only those who placed an order) SELECT c.id, c.first_name, o.order_id, o.sales FROM customers AS c INNER JOIN orders AS o ON c.id = o.customer_id; LEFT JOIN -- Get all customers along with their orders (including customers without orders) SELECT c.id, c.first_name, o.order_id, o.sales FROM customers AS c LEFT JOIN orders AS o ON c.id = o.customer_id; RIGHT JOIN -- Get all customers along with their orders (including orders without customers) SELECT c.id, c.first_name, o.order_id, o.customer_id, o.sales FROM customers AS c RIGHT JOIN orders AS o ON c.id = o.customer_id; Alternative to RIGHT JOIN (using LEFT JOIN) SELECT c.id, c.first_name, o.order_id, o.sales FROM orders AS o LEFT JOIN customers AS c ON c.id = o.customer_id; FULL JOIN -- Get all customers and all orders, even if there’s no match SELECT c.id, c.first_name, o.order_id, o.customer_id, o.sales FROM customers AS c FULL JOIN orders AS o ON c.id = o.customer_id; 2. Advanced Joins LEFT ANTI JOIN -- Customers who haven&#39;t placed any order SELECT * FROM customers AS c LEFT JOIN orders AS o ON c.id = o.customer_id WHERE o.customer_id IS NULL; RIGHT ANTI JOIN -- Orders without matching customers SELECT * FROM customers AS c RIGHT JOIN orders AS o ON c.id = o.customer_id WHERE c.id IS NULL; Alternative to RIGHT ANTI JOIN (using LEFT JOIN) SELECT * FROM orders AS o LEFT JOIN customers AS c ON c.id = o.customer_id WHERE c.id IS NULL; Alternative to INNER JOIN (using LEFT JOIN) SELECT * FROM customers AS c LEFT JOIN orders AS o ON c.id = o.customer_id WHERE o.customer_id IS NOT NULL; FULL ANTI JOIN -- Find customers without orders and orders without customers SELECT c.id, c.first_name, o.order_id, o.customer_id, o.sales FROM customers AS c FULL JOIN orders AS o ON c.id = o.customer_id WHERE o.customer_id IS NULL OR c.id IS NULL; CROSS JOIN -- Generate all possible combinations of customers and orders SELECT * FROM customers CROSS JOIN orders; 3. Multiple Table Joins (4 Tables) Task: Using SalesDB, retrieve a list of all orders along with related customer, product, and employee details. For each order, display:</description>
    </item>
    <item>
      <title>Set Operations</title>
      <link>https://example.org/sql/set-operations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/set-operations/</guid>
      <description>SQL set operations enable you to combine results from multiple queries into a single result set.&#xA;This guide demonstrates the rules and usage of UNION, UNION ALL, EXCEPT, and INTERSECT.&#xA;1. SQL Operation Rules Rule: Data Types The data types of columns in each query should match.&#xA;SELECT FirstName, LastName, Country FROM Sales.Customers UNION SELECT FirstName, LastName FROM Sales.Employees; Rule: Data Types (Example) SELECT CustomerID, LastName FROM Sales.Customers UNION SELECT FirstName, LastName FROM Sales.Employees; Rule: Column Order The order of the columns in each query must be the same.</description>
    </item>
    <item>
      <title>String Functions</title>
      <link>https://example.org/sql/string-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/string-functions/</guid>
      <description>This document provides an overview of SQL string functions, which allow manipulation, transformation, and extraction of text data efficiently.&#xA;1. Manipulations CONCAT() – String Concatenation -- Concatenate first name and country into one column SELECT CONCAT(first_name, &#39;-&#39;, country) AS full_info FROM customers; LOWER() &amp; UPPER() – Case Transformation -- Convert the first name to lowercase SELECT LOWER(first_name) AS lower_case_name FROM customers; -- Convert the first name to uppercase SELECT UPPER(first_name) AS upper_case_name FROM customers; TRIM() – Remove White Spaces -- Find customers whose first name contains leading or trailing spaces SELECT first_name, LEN(first_name) AS len_name, LEN(TRIM(first_name)) AS len_trim_name, LEN(first_name) - LEN(TRIM(first_name)) AS flag FROM customers WHERE LEN(first_name) != LEN(TRIM(first_name)); -- Alternative: -- WHERE first_name != TRIM(first_name) REPLACE() – Replace or Remove Values -- Remove dashes (-) from a phone number SELECT &#39;123-456-7890&#39; AS phone, REPLACE(&#39;123-456-7890&#39;, &#39;-&#39;, &#39;/&#39;) AS clean_phone; -- Replace file extension from .txt to .csv SELECT &#39;report.txt&#39; AS old_filename, REPLACE(&#39;report.txt&#39;, &#39;.txt&#39;, &#39;.csv&#39;) AS new_filename; 2. Calculation LEN() – String Length -- Calculate the length of each customer&#39;s first name SELECT first_name, LEN(first_name) AS name_length FROM customers; 3. Substring Extraction LEFT() &amp; RIGHT() -- Retrieve the first two characters of each first name SELECT first_name, LEFT(TRIM(first_name), 2) AS first_2_chars FROM customers; -- Retrieve the last two characters of each first name SELECT first_name, RIGHT(first_name, 2) AS last_2_chars FROM customers; SUBSTRING() -- Retrieve a list of customers&#39; first names after removing the first character SELECT first_name, SUBSTRING(TRIM(first_name), 2, LEN(first_name)) AS trimmed_name FROM customers; 4. Nesting Functions – Nesting example SELECT first_name, UPPER(LOWER(first_name)) AS nesting FROM customers;</description>
    </item>
    <item>
      <title>Number Functions</title>
      <link>https://example.org/sql/number-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/number-functions/</guid>
      <description>This document provides an overview of SQL number functions, which allow performing mathematical operations and formatting numerical values.&#xA;1. Rounding Functions ROUND() – Rounding Numbers -- Demonstrate rounding a number to different decimal places SELECT 3.516 AS original_number, ROUND(3.516, 2) AS round_2, ROUND(3.516, 1) AS round_1, ROUND(3.516, 0) AS round_0; 2. Absolute Value Function ABS() – Absolute Value -- Demonstrate absolute value function SELECT -10 AS original_number, ABS(-10) AS absolute_value_negative, ABS(10) AS absolute_value_positive;</description>
    </item>
    <item>
      <title>Date &amp; Time Functions</title>
      <link>https://example.org/sql/date-time1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/date-time1/</guid>
      <description>This guide demonstrates various date and time functions in SQL.&#xA;It covers GETDATE, DATETRUNC, DATENAME, DATEPART, YEAR, MONTH, DAY, EOMONTH, FORMAT, CONVERT, CAST, DATEADD, DATEDIFF, and ISDATE.&#xA;1. GETDATE() | Date Values -- Display OrderID, CreationTime, a hard-coded date, and the current system date SELECT OrderID, CreationTime, &#39;2025-08-20&#39; AS HardCoded, GETDATE() AS Today FROM Sales.Orders; 2. Date Part Extractions (DATETRUNC, DATENAME, DATEPART, YEAR, MONTH, DAY) -- Extract various parts of CreationTime SELECT OrderID, CreationTime, DATETRUNC(year, CreationTime) AS Year_dt, DATETRUNC(day, CreationTime) AS Day_dt, DATETRUNC(minute, CreationTime) AS Minute_dt, DATENAME(month, CreationTime) AS Month_dn, DATENAME(weekday, CreationTime) AS Weekday_dn, DATENAME(day, CreationTime) AS Day_dn, DATENAME(year, CreationTime) AS Year_dn, DATEPART(year, CreationTime) AS Year_dp, DATEPART(month, CreationTime) AS Month_dp, DATEPART(day, CreationTime) AS Day_dp, DATEPART(hour, CreationTime) AS Hour_dp, DATEPART(quarter, CreationTime) AS Quarter_dp, DATEPART(week, CreationTime) AS Week_dp, YEAR(CreationTime) AS Year, MONTH(CreationTime) AS Month, DAY(CreationTime) AS Day FROM Sales.Orders; 3. DATETRUNC() Data Aggregation -- Aggregate orders by year SELECT DATETRUNC(year, CreationTime) AS Creation, COUNT(*) AS OrderCount FROM Sales.Orders GROUP BY DATETRUNC(year, CreationTime); 4. EOMONTH() -- Display end-of-month date for each order SELECT OrderID, CreationTime, EOMONTH(CreationTime) AS EndOfMonth FROM Sales.Orders; 5. Date Parts | Use Cases -- Orders per year SELECT YEAR(OrderDate) AS OrderYear, COUNT(*) AS TotalOrders FROM Sales.Orders GROUP BY YEAR(OrderDate); -- Orders per month SELECT MONTH(OrderDate) AS OrderMonth, COUNT(*) AS TotalOrders FROM Sales.Orders GROUP BY MONTH(OrderDate); -- Orders per month (friendly names) SELECT DATENAME(month, OrderDate) AS OrderMonth, COUNT(*) AS TotalOrders FROM Sales.Orders GROUP BY DATENAME(month, OrderDate); -- Orders placed in February SELECT * FROM Sales.Orders WHERE MONTH(OrderDate) = 2; 6. FORMAT() -- Format CreationTime into different formats SELECT OrderID, CreationTime, FORMAT(CreationTime, &#39;MM-dd-yyyy&#39;) AS USA_Format, FORMAT(CreationTime, &#39;dd-MM-yyyy&#39;) AS EURO_Format, FORMAT(CreationTime, &#39;dd&#39;) AS dd, FORMAT(CreationTime, &#39;ddd&#39;) AS ddd, FORMAT(CreationTime, &#39;dddd&#39;) AS dddd, FORMAT(CreationTime, &#39;MM&#39;) AS MM, FORMAT(CreationTime, &#39;MMM&#39;) AS MMM, FORMAT(CreationTime, &#39;MMMM&#39;) AS MMMM FROM Sales.Orders; -- Custom format example SELECT OrderID, CreationTime, &#39;Day &#39; + FORMAT(CreationTime, &#39;ddd MMM&#39;) + &#39; Q&#39; + DATENAME(quarter, CreationTime) + &#39; &#39; + FORMAT(CreationTime, &#39;yyyy hh:mm:ss tt&#39;) AS CustomFormat FROM Sales.Orders; -- Orders per month (formatted &#34;MMM yy&#34;) SELECT FORMAT(CreationTime, &#39;MMM yy&#39;) AS OrderDate, COUNT(*) AS TotalOrders FROM Sales.Orders GROUP BY FORMAT(CreationTime, &#39;MMM yy&#39;); 7. CONVERT() -- Conversion using CONVERT SELECT CONVERT(INT, &#39;123&#39;) AS [String to Int CONVERT], CONVERT(DATE, &#39;2025-08-20&#39;) AS [String to Date CONVERT], CreationTime, CONVERT(DATE, CreationTime) AS [Datetime to Date CONVERT], CONVERT(VARCHAR, CreationTime, 32) AS [USA Std. Style:32], CONVERT(VARCHAR, CreationTime, 34) AS [EURO Std. Style:34] FROM Sales.Orders; 8. CAST() -- Conversion using CAST SELECT CAST(&#39;123&#39; AS INT) AS [String to Int], CAST(123 AS VARCHAR) AS [Int to String], CAST(&#39;2025-08-20&#39; AS DATE) AS [String to Date], CAST(&#39;2025-08-20&#39; AS DATETIME2) AS [String to Datetime], CreationTime, CAST(CreationTime AS DATE) AS [Datetime to Date] FROM Sales.Orders; 9. DATEADD / DATEDIFF -- Date arithmetic SELECT OrderID, OrderDate, DATEADD(day, -10, OrderDate) AS TenDaysBefore, DATEADD(month, 3, OrderDate) AS ThreeMonthsLater, DATEADD(year, 2, OrderDate) AS TwoYearsLater FROM Sales.Orders; -- Employee ages SELECT EmployeeID, BirthDate, DATEDIFF(year, BirthDate, GETDATE()) AS Age FROM Sales.Employees; -- Avg shipping duration SELECT MONTH(OrderDate) AS OrderMonth, AVG(DATEDIFF(day, OrderDate, ShipDate)) AS AvgShip FROM Sales.Orders GROUP BY MONTH(OrderDate); -- Time gap analysis SELECT OrderID, OrderDate AS CurrentOrderDate, LAG(OrderDate) OVER (ORDER BY OrderDate) AS PreviousOrderDate, DATEDIFF(day, LAG(OrderDate) OVER (ORDER BY OrderDate), OrderDate) AS NrOfDays FROM Sales.Orders; 10. ISDATE() -- Validate OrderDate using ISDATE SELECT OrderDate, ISDATE(OrderDate) AS IsValidDate, CASE WHEN ISDATE(OrderDate) = 1 THEN CAST(OrderDate AS DATE) ELSE &#39;9999-01-01&#39; END AS NewOrderDate FROM ( SELECT &#39;2025-08-20&#39; AS OrderDate UNION SELECT &#39;2025-08-21&#39; UNION SELECT &#39;2025-08-23&#39; UNION SELECT &#39;2025-08&#39; ) AS t; -- WHERE ISDATE(OrderDate) = 0</description>
    </item>
    <item>
      <title>Date &amp; Time Formats</title>
      <link>https://example.org/sql/date-time2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/date-time2/</guid>
      <description>This guide demonstrates all possible date parts, number formats, and culture-specific styles available in SQL Server.&#xA;1. Numeric Format Specifiers SELECT &#39;N&#39; AS FormatType, FORMAT(1234.56, &#39;N&#39;) AS FormattedValue UNION ALL SELECT &#39;P&#39;, FORMAT(1234.56, &#39;P&#39;) UNION ALL SELECT &#39;C&#39;, FORMAT(1234.56, &#39;C&#39;) UNION ALL SELECT &#39;E&#39;, FORMAT(1234.56, &#39;E&#39;) UNION ALL SELECT &#39;F&#39;, FORMAT(1234.56, &#39;F&#39;) UNION ALL SELECT &#39;N0&#39;, FORMAT(1234.56, &#39;N0&#39;) UNION ALL SELECT &#39;N1&#39;, FORMAT(1234.56, &#39;N1&#39;) UNION ALL SELECT &#39;N2&#39;, FORMAT(1234.56, &#39;N2&#39;) UNION ALL SELECT &#39;N_de-DE&#39;, FORMAT(1234.56, &#39;N&#39;, &#39;de-DE&#39;) UNION ALL SELECT &#39;N_en-US&#39;, FORMAT(1234.56, &#39;N&#39;, &#39;en-US&#39;); 2. Date Format Specifiers SELECT &#39;D&#39; AS FormatType, FORMAT(GETDATE(), &#39;D&#39;) AS FormattedValue, &#39;Full date pattern&#39; AS Description UNION ALL SELECT &#39;d&#39;, FORMAT(GETDATE(), &#39;d&#39;), &#39;Short date pattern&#39; UNION ALL SELECT &#39;dd&#39;, FORMAT(GETDATE(), &#39;dd&#39;), &#39;Day of month with leading zero&#39; UNION ALL SELECT &#39;ddd&#39;, FORMAT(GETDATE(), &#39;ddd&#39;), &#39;Abbreviated name of day&#39; UNION ALL SELECT &#39;dddd&#39;, FORMAT(GETDATE(), &#39;dddd&#39;), &#39;Full name of day&#39; UNION ALL SELECT &#39;M&#39;, FORMAT(GETDATE(), &#39;M&#39;), &#39;Month without leading zero&#39; UNION ALL SELECT &#39;MM&#39;, FORMAT(GETDATE(), &#39;MM&#39;), &#39;Month with leading zero&#39; UNION ALL SELECT &#39;MMM&#39;, FORMAT(GETDATE(), &#39;MMM&#39;), &#39;Abbreviated name of month&#39; UNION ALL SELECT &#39;MMMM&#39;, FORMAT(GETDATE(), &#39;MMMM&#39;), &#39;Full name of month&#39; UNION ALL SELECT &#39;yy&#39;, FORMAT(GETDATE(), &#39;yy&#39;), &#39;Two-digit year&#39; UNION ALL SELECT &#39;yyyy&#39;, FORMAT(GETDATE(), &#39;yyyy&#39;), &#39;Four-digit year&#39; UNION ALL SELECT &#39;hh&#39;, FORMAT(GETDATE(), &#39;hh&#39;), &#39;12-hour clock with leading zero&#39; UNION ALL SELECT &#39;HH&#39;, FORMAT(GETDATE(), &#39;HH&#39;), &#39;24-hour clock with leading zero&#39; UNION ALL SELECT &#39;m&#39;, FORMAT(GETDATE(), &#39;m&#39;), &#39;Minutes without leading zero&#39; UNION ALL SELECT &#39;mm&#39;, FORMAT(GETDATE(), &#39;mm&#39;), &#39;Minutes with leading zero&#39; UNION ALL SELECT &#39;s&#39;, FORMAT(GETDATE(), &#39;s&#39;), &#39;Seconds without leading zero&#39; UNION ALL SELECT &#39;ss&#39;, FORMAT(GETDATE(), &#39;ss&#39;), &#39;Seconds with leading zero&#39; UNION ALL SELECT &#39;f&#39;, FORMAT(GETDATE(), &#39;f&#39;), &#39;Tenths of a second&#39; UNION ALL SELECT &#39;ff&#39;, FORMAT(GETDATE(), &#39;ff&#39;), &#39;Hundredths of a second&#39; UNION ALL SELECT &#39;fff&#39;, FORMAT(GETDATE(), &#39;fff&#39;), &#39;Milliseconds&#39; UNION ALL SELECT &#39;T&#39;, FORMAT(GETDATE(), &#39;T&#39;), &#39;Full AM/PM designator&#39; UNION ALL SELECT &#39;t&#39;, FORMAT(GETDATE(), &#39;t&#39;), &#39;Single char AM/PM designator&#39; UNION ALL SELECT &#39;tt&#39;, FORMAT(GETDATE(), &#39;tt&#39;), &#39;Two char AM/PM designator&#39;; 3. DatePart / DateName / DateTrunc Comparisons SELECT &#39;Year&#39; AS DatePart, DATEPART(year, GETDATE()), DATENAME(year, GETDATE()), DATETRUNC(year, GETDATE()) UNION ALL SELECT &#39;Quarter&#39;, DATEPART(quarter, GETDATE()), DATENAME(quarter, GETDATE()), DATETRUNC(quarter, GETDATE()) UNION ALL SELECT &#39;Month&#39;, DATEPART(month, GETDATE()), DATENAME(month, GETDATE()), DATETRUNC(month, GETDATE()) UNION ALL SELECT &#39;DayOfYear&#39;, DATEPART(dayofyear, GETDATE()), DATENAME(dayofyear, GETDATE()), DATETRUNC(dayofyear, GETDATE()) UNION ALL SELECT &#39;Day&#39;, DATEPART(day, GETDATE()), DATENAME(day, GETDATE()), DATETRUNC(day, GETDATE()) UNION ALL SELECT &#39;Week&#39;, DATEPART(week, GETDATE()), DATENAME(week, GETDATE()), DATETRUNC(week, GETDATE()) UNION ALL SELECT &#39;Weekday&#39;, DATEPART(weekday, GETDATE()), DATENAME(weekday, GETDATE()), NULL UNION ALL SELECT &#39;Hour&#39;, DATEPART(hour, GETDATE()), DATENAME(hour, GETDATE()), DATETRUNC(hour, GETDATE()) UNION ALL SELECT &#39;Minute&#39;, DATEPART(minute, GETDATE()), DATENAME(minute, GETDATE()), DATETRUNC(minute, GETDATE()) UNION ALL SELECT &#39;Second&#39;, DATEPART(second, GETDATE()), DATENAME(second, GETDATE()), DATETRUNC(second, GETDATE()) UNION ALL SELECT &#39;Millisecond&#39;, DATEPART(millisecond, GETDATE()), DATENAME(millisecond, GETDATE()), DATETRUNC(millisecond, GETDATE()) UNION ALL SELECT &#39;Microsecond&#39;, DATEPART(microsecond, GETDATE()), DATENAME(microsecond, GETDATE()), NULL UNION ALL SELECT &#39;Nanosecond&#39;, DATEPART(nanosecond, GETDATE()), DATENAME(nanosecond, GETDATE()), NULL UNION ALL SELECT &#39;ISOWeek&#39;, DATEPART(iso_week, GETDATE()), DATENAME(iso_week, GETDATE()), DATETRUNC(iso_week, GETDATE()); 4. Culture Code Formatting SELECT &#39;en-US&#39; AS CultureCode, FORMAT(1234567.89, &#39;N&#39;, &#39;en-US&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;en-US&#39;) UNION ALL SELECT &#39;en-GB&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;en-GB&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;en-GB&#39;) UNION ALL SELECT &#39;fr-FR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;fr-FR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;fr-FR&#39;) UNION ALL SELECT &#39;de-DE&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;de-DE&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;de-DE&#39;) UNION ALL SELECT &#39;es-ES&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;es-ES&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;es-ES&#39;) UNION ALL SELECT &#39;zh-CN&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;zh-CN&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;zh-CN&#39;) UNION ALL SELECT &#39;ja-JP&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;ja-JP&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;ja-JP&#39;) UNION ALL SELECT &#39;ko-KR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;ko-KR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;ko-KR&#39;) UNION ALL SELECT &#39;pt-BR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;pt-BR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;pt-BR&#39;) UNION ALL SELECT &#39;it-IT&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;it-IT&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;it-IT&#39;) UNION ALL SELECT &#39;nl-NL&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;nl-NL&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;nl-NL&#39;) UNION ALL SELECT &#39;ru-RU&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;ru-RU&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;ru-RU&#39;) UNION ALL SELECT &#39;ar-SA&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;ar-SA&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;ar-SA&#39;) UNION ALL SELECT &#39;el-GR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;el-GR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;el-GR&#39;) UNION ALL SELECT &#39;tr-TR&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;tr-TR&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;tr-TR&#39;) UNION ALL SELECT &#39;he-IL&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;he-IL&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;he-IL&#39;) UNION ALL SELECT &#39;hi-IN&#39;, FORMAT(1234567.89, &#39;N&#39;, &#39;hi-IN&#39;), FORMAT(GETDATE(), &#39;D&#39;, &#39;hi-IN&#39;);</description>
    </item>
    <item>
      <title>NULL Functions</title>
      <link>https://example.org/sql/null-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/null-functions/</guid>
      <description>This guide covers essential SQL functions for handling NULL values in different scenarios such as aggregation, mathematical operations, sorting, joins, and comparisons.&#xA;1. Handle NULL - Data Aggregation Replace NULL values using COALESCE to ensure accurate averages.&#xA;SELECT CustomerID, Score, COALESCE(Score, 0) AS Score2, AVG(Score) OVER () AS AvgScores, AVG(COALESCE(Score, 0)) OVER () AS AvgScores2 FROM Sales.Customers; 2. Handle NULL - Mathematical Operators Concatenate first and last names safely and add bonus points with COALESCE.</description>
    </item>
    <item>
      <title>CASE Statement</title>
      <link>https://example.org/sql/case-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/case-statement/</guid>
      <description>1. Categorize Data Create sales categories based on value ranges.&#xA;SELECT Category, SUM(Sales) AS TotalSales FROM ( SELECT OrderID, Sales, CASE WHEN Sales &gt; 50 THEN &#39;High&#39; WHEN Sales &gt; 20 THEN &#39;Medium&#39; ELSE &#39;Low&#39; END AS Category FROM Sales.Orders ) AS t GROUP BY Category ORDER BY TotalSales DESC; 2. Mapping Map country names to abbreviations.&#xA;SELECT CustomerID, FirstName, LastName, Country, CASE WHEN Country = &#39;Germany&#39; THEN &#39;DE&#39; WHEN Country = &#39;USA&#39; THEN &#39;US&#39; ELSE &#39;n/a&#39; END AS CountryAbbr FROM Sales.Customers; 3. Quick Form of CASE Statement Use the shorthand CASE syntax for direct equality comparisons.</description>
    </item>
    <item>
      <title>Aggregate Functions</title>
      <link>https://example.org/sql/aggregate-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/aggregate-functions/</guid>
      <description>SQL aggregate functions perform calculations on multiple rows of data and return summary results.&#xA;1. Basic Aggregate Functions COUNT – Count rows SELECT COUNT(*) AS total_customers FROM customers; SUM – Total of values SELECT SUM(sales) AS total_sales FROM orders; AVG – Average of values SELECT AVG(sales) AS avg_sales FROM orders; MAX – Maximum value SELECT MAX(score) AS max_score FROM customers; MIN – Minimum value SELECT MIN(score) AS min_score FROM customers; 2. Grouped Aggregations – GROUP BY Aggregate results per group.</description>
    </item>
    <item>
      <title>Window Functions</title>
      <link>https://example.org/sql/window-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/window-functions/</guid>
      <description>SQL window functions enable advanced calculations across sets of rows related to the current row without needing complex subqueries or joins. They support clauses like OVER, PARTITION, ORDER, FRAME, along with important rules and group-based use cases.&#xA;Table of Contents SQL Window Basics SQL Window OVER Clause SQL Window PARTITION Clause SQL Window ORDER Clause SQL Window FRAME Clause SQL Window Rules SQL Window with GROUP BY 1. SQL Window Basics TASK 1 – Calculate the Total Sales Across All Orders SELECT SUM(Sales) AS Total_Sales FROM Sales.Orders; TASK 2 – Calculate the Total Sales for Each Product SELECT ProductID, SUM(Sales) AS Total_Sales FROM Sales.Orders GROUP BY ProductID; 2. SQL Window OVER Clause TASK 3 – Total sales across all orders with order details SELECT OrderID, OrderDate, ProductID, Sales, SUM(Sales) OVER () AS Total_Sales FROM Sales.Orders; 3. SQL Window PARTITION Clause TASK 4 – Total sales overall and per product SELECT OrderID, OrderDate, ProductID, Sales, SUM(Sales) OVER () AS Total_Sales, SUM(Sales) OVER (PARTITION BY ProductID) AS Sales_By_Product FROM Sales.Orders; TASK 5 – Total sales overall, per product, and per product-status combination SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER () AS Total_Sales, SUM(Sales) OVER (PARTITION BY ProductID) AS Sales_By_Product, SUM(Sales) OVER (PARTITION BY ProductID, OrderStatus) AS Sales_By_Product_Status FROM Sales.Orders; 4. SQL Window ORDER Clause TASK 6 – Rank each order by sales (highest to lowest) SELECT OrderID, OrderDate, Sales, RANK() OVER (ORDER BY Sales DESC) AS Rank_Sales FROM Sales.Orders; 5. SQL Window FRAME Clause TASK 7 – Total sales by order status (current + next two orders) SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING ) AS Total_Sales FROM Sales.Orders; TASK 8 – Total sales by order status (current + previous two orders) SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW ) AS Total_Sales FROM Sales.Orders; TASK 9 – Total sales by order status (previous two orders only) SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS 2 PRECEDING ) AS Total_Sales FROM Sales.Orders; TASK 10 – Cumulative sales up to the current order SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS Total_Sales FROM Sales.Orders; TASK 11 – Cumulative sales from start to current row SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER ( PARTITION BY OrderStatus ORDER BY OrderDate ROWS UNBOUNDED PRECEDING ) AS Total_Sales FROM Sales.Orders; 6. SQL Window Rules RULE 1 – Window functions can only be used in SELECT or ORDER BY SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(Sales) OVER (PARTITION BY OrderStatus) AS Total_Sales FROM Sales.Orders WHERE SUM(Sales) OVER (PARTITION BY OrderStatus) &gt; 100; -- ❌ Invalid RULE 2 – Window functions cannot be nested SELECT OrderID, OrderDate, ProductID, OrderStatus, Sales, SUM(SUM(Sales) OVER (PARTITION BY OrderStatus)) OVER (PARTITION BY OrderStatus) AS Total_Sales -- ❌ Invalid nesting FROM Sales.Orders; 7. SQL Window with GROUP BY TASK 12 – Rank customers by total sales SELECT CustomerID, SUM(Sales) AS Total_Sales, RANK() OVER (ORDER BY SUM(Sales) DESC) AS Rank_Customers FROM Sales.Orders GROUP BY CustomerID;</description>
    </item>
    <item>
      <title>Window Aggregate Functions</title>
      <link>https://example.org/sql/window_aggregations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/sql/window_aggregations/</guid>
      <description>These functions allow you to perform aggregate calculations over a set of rows without the need for complex subqueries. They enable you to compute counts, sums, averages, minimums, and maximums while still retaining access to individual row details.&#xA;Table of Contents COUNT SUM AVG MAX / MIN ROLLING SUM &amp; AVERAGE Use Case COUNT Task 1: Find the Total Number of Orders and the Total Number of Orders for Each Customer SELECT OrderID, OrderDate, CustomerID, COUNT(*) OVER() AS TotalOrders, COUNT(*) OVER(PARTITION BY CustomerID) AS OrdersByCustomers FROM Sales.Orders Task 2: Find the Total Number of Customers, Scores, and Countries SELECT *, COUNT(*) OVER () AS TotalCustomersStar, COUNT(1) OVER () AS TotalCustomersOne, COUNT(Score) OVER() AS TotalScores, COUNT(Country) OVER() AS TotalCountries FROM Sales.Customers Task 3: Check whether the table ‘OrdersArchive’ contains any duplicate rows SELECT * FROM ( SELECT *, COUNT(*) OVER(PARTITION BY OrderID) AS CheckDuplicates FROM Sales.OrdersArchive ) t WHERE CheckDuplicates &gt; 1 SUM Task 4: Find the Total Sales Across All Orders and per Product SELECT OrderID, OrderDate, Sales, ProductID, SUM(Sales) OVER () AS TotalSales, SUM(Sales) OVER (PARTITION BY ProductID) AS SalesByProduct FROM Sales.Orders Task 5: Find the Percentage Contribution of Each Product’s Sales to the Total Sales SELECT OrderID, ProductID, Sales, SUM(Sales) OVER () AS TotalSales, ROUND(CAST(Sales AS FLOAT) / SUM(Sales) OVER () * 100, 2) AS PercentageOfTotal FROM Sales.Orders AVG Task 6: Find the Average Sales Across All Orders and per Product SELECT OrderID, OrderDate, Sales, ProductID, AVG(Sales) OVER () AS AvgSales, AVG(Sales) OVER (PARTITION BY ProductID) AS AvgSalesByProduct FROM Sales.Orders Task 7: Find the Average Scores of Customers SELECT CustomerID, LastName, Score, COALESCE(Score, 0) AS CustomerScore, AVG(Score) OVER () AS AvgScore, AVG(COALESCE(Score, 0)) OVER () AS AvgScoreWithoutNull FROM Sales.Customers Task 8: Find all orders where Sales exceed the average Sales across all orders SELECT * FROM ( SELECT OrderID, ProductID, Sales, AVG(Sales) OVER () AS Avg_Sales FROM Sales.Orders ) t WHERE Sales &gt; Avg_Sales MAX / MIN Task 9: Find the Highest and Lowest Sales across all orders SELECT MIN(Sales) AS MinSales, MAX(Sales) AS MaxSales FROM Sales.Orders Task 10: Find the Lowest Sales across all orders and by Product SELECT OrderID, ProductID, OrderDate, Sales, MIN(Sales) OVER () AS LowestSales, MIN(Sales) OVER (PARTITION BY ProductID) AS LowestSalesByProduct FROM Sales.Orders Task 11: Show the employees who have the highest salaries SELECT * FROM ( SELECT *, MAX(Salary) OVER() AS HighestSalary FROM Sales.Employees ) t WHERE Salary = HighestSalary Task 12: Find the deviation of each Sale from the minimum and maximum Sales SELECT OrderID, OrderDate, ProductID, Sales, MAX(Sales) OVER () AS HighestSales, MIN(Sales) OVER () AS LowestSales, Sales - MIN(Sales) OVER () AS DeviationFromMin, MAX(Sales) OVER () - Sales AS DeviationFromMax FROM Sales.Orders ROLLING SUM &amp; AVERAGE Use Case Task 13: Calculate the moving average of Sales for each Product over time SELECT OrderID, ProductID, OrderDate, Sales, AVG(Sales) OVER (PARTITION BY ProductID) AS AvgByProduct, AVG(Sales) OVER (PARTITION BY ProductID ORDER BY OrderDate) AS MovingAvg FROM Sales.Orders Task 14: Calculate the moving average of Sales for each Product over time, including only the next order SELECT OrderID, ProductID, OrderDate, Sales, AVG(Sales) OVER (PARTITION BY ProductID ORDER BY OrderDate ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS RollingAvg FROM Sales.Orders</description>
    </item>
  </channel>
</rss>